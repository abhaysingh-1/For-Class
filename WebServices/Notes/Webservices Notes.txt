Web Services Introduction
============================
> Servlets, JSP along with JDBC helps to develop 
  Web Application

> However "Web Services" a.k.a "Application Services"
  helps web applications to interact with any other 
  applications (Mobile Apps / Desktop Applications 
  / Web Applications)

> Web Services, as name implies, they are the 
  services avilable in "Web". They take the request 
  from Applications, via any communication protocol such
  as HTTP & generate Response

> Web Services, is a concept, are independent of
  - Platform
  - Programing Languages &
  - Applications
  
> Web Services take Web-applications to the 
  Next Level!!!

> Unlike Web Applications, Web Services do not 
  provide the user with a GUI. 
  
> In other words Web services are meant for 
  "Inter-System Communication
  / Application-to-Application Interactions but not
  for Users"
  
> Hence Web Services do not require the use of 
  browsers or HTML
 
> Few real time examples of Web Services
  - Mobile Apps (ex: GMail App) communicate with 
    their correspondig Web Applications (ex: GMail) 
    using Web Services
	
  - Uber / OLA Mobile Apps/Web Application interact 
    with Google Maps using Web Services
	
  - BookMyShow Web Application / Mobile Application 
    interact with PVR Web Application using Web   
    Services   
 
 
 
 
 
> Web Service has two participants:
  1. Service Provider / Producer
  2. Service Consumer / Requester
  
> Service Provider exposes the "Service on Web" &  
  Service Consumer uses this "Web Service"

> Service Provider should be a Web Application, however  
  Service Consumer can be Desktop/Mobile Application or Web Application

> There are 2 types of Web Services
  1. RESTful Web Services
  2. SOAP Web Services / XML Web Services 

> Java provides 2 API's to develop these web services
  1. "JAX-RS" API for developing 
	  "RESTful Web Services"
	  
  2. "JAX-WS" API for developing 
      "SOAP Web Services"

> "javax.ws.rs.*" is the package representation 
  of JAX-RS API  
  
  "javax.jws.*" is the package representation 
  of JAX-WS API  
  
  
  
Why Web Services / Advantages of Web Services
==============================================

1. Web Services Interoperability (WS-I)
------------------------------------------
> Web Services are "Application, Platform and 
  Technology Independent"
  
> Ex: VB / .NET applications can talk to Java Web 
  Services and vice versa. Thus helping the 
  organisations to use existing applications which 
  are developed using other technologies 
  (may be legacy) 

> Also Web Services helps/allows different applications to 
  share data among themselves

> Ex: Uber / OLA and Google Maps shares the data 
      among each other

	  
	  
	  
2. Loosely Coupled 
------------------------
> Each application is independent of one another. 
  Hence changes done to one application will not 
  impact the "unrelated areas"
  
> Ex: Changes / Modifications done at Uber / OLA 
      will not impact Google Maps

  
3. No need of re-inventing the wheel
-------------------------------------
> Web Services reduces the software development time
 
> This helps the other business partners to quickly 
  develop application and start doing business
  
> This helps business to save time and money by 
  cutting development time

Ex: Uber / OLA can make use of Google Maps 


4. Business Opportunity
-----------------------
> Web Services will open the door for new business 
  opportunities by making it easy to connect with 
  partners

> Ex: Domino's can get the order from Food Panda / 
      Swiggy along with getting orders from its 
	  own site 

	  
	  

5. Service Reuse
------------------
> Web Services takes code reuse a step further

> A specific service within the organisation is 
  only coded once and used over and over again by 
  other applications
  
> Ex: An organization can have a "Single Payment 
     Gateway service" which helps other web 
	 applications of that organization to interact 
	 with "Payment Gateways" 


	 
Web Services Architecture
===========================
NOTE:
-----
> Web Service Producer MUST be a Web Application
> However Web Service Consumer can be 
  - Web Application OR
  - Desktop Application OR
  - Mobile Application




Steps Followed to Create the 
First Web Service Producer & Consumer Web Applications
==============================================================================================

I. Steps for Web Service "Producer Web Application"
---------------------------------------------------
1. Created the Maven Project by providing the below 
   information
   
   Archetype 	: maven-archetype-webapp
   Group ID	 	: com.google
   Artifact ID	: googlemaps
   
2. Under Java Resources if "src/main/java" folder is not
   present then, create it
   
3. Added the "Glassfish Jersey & Servlet" Dependencies to
   pom.xml    

4. Configured Jersey "ServletContainer" in web.xml 

5. Created the Java Class which hosts the Rest 
   Webservices using Jersey Framework


II. Steps for Web Service Consumer Web Application
-----------------------------------------------------

1. Created the Maven Project by providing the below 
   information
   
   Archetype 	: maven-archetype-webapp
   Group ID	 	: org.jspiders
   Artifact ID	: mywebapp

2. Under Java Resources if "src/main/java" folder is not
   present then, create it

3. Added the "Glassfish Jersey & Servlet" Dependencies to
   pom.xml    
   
3. Created the Servlet which interact with above 
   web application to consume the Web Services

4. Configured this Servlet in web.xml 

Maven Dependencies
=======================
> URL to get the Dependencies : 
  https://mvnrepository.com/
  
> Jersey Dependencies	:
	jersey-client
	jersey-server
	jersey-container-servlet
	jersey-media-json-jackson
	jersey-common
	jersey-media-multipart
	jersey-container-servlet-core
	
> Servelet Dependency	:
	javax.servlet-api

	
	

Maven Installation Steps 
===========================================================

Pre-requirement :
------------------ 
JDK is Required & JAVA_HOME environment variable 
should be set

Steps
---------
1. Download Maven Binary from Apache Maven
2. Set the Following environment Variables
   - M2_HOME (Its the latest variable)
   - MAVEN_HOME (Some applications stil refer this variable)
   - Modify path variable to add %M2_HOME%/bin
3. run mvn in commond 

	
Data Formats
==============
> W.K.T Web Services helps different applications to interact
  with Web Applications

> In this interactions there should be a exchange of Data & that
  data should have some specific format
  
> The most commonly used Data formats are
  1. XML
  2. JSON  
	
	
	
eXtensible Markup Language (XML) - Part I:-
==================================================
> XML is "Programing Language & Platform Independent 
  Language" which helps to store and transport data

> Different Applications which are developed using 
  different technologies can Transfer the Data among
  themselves with the help of XML

> As the name implies it's an extension of HTML & 
  hence XML looks similar to HTML but itâ€™s not a HTML

> XML has User-defind Tags. XML tags are also called
  as "elements"

> XML Elements are "Case Sensitive"

> XML is "Strictly Typed" Language & Hence every 
  opening element should have corresponding closing 
  element and also XML elements Must be Properly 
  Nested/closed
  
  Ex: <employee>
			<name>Praveen</name>
	   </employee>
  
  Note:- 
  - In the above example first you should closed
    </name> & then </employee> but 
  
  - In HTML its not mandatory. For example, 
    <B><U><I>My Text</U></I></B> works perfectly fine
  
> Below line is called as "XML prolog", which is 
  optional. If it exists, it must be the First Line 
  of XML  
  <?xml version="1.0" encoding="UTF-8" ?>

> The syntax of XML comment is similar to that of HTML
  <!-- This is a comment -->
  
> File extension of XML is ".xml"  
  
> MIME type (Content Type) of XML is "application/xml"   

   
   
   
   
   
XML Structure
================
> Like HTML, XML follows a Tree Structure

> An XML tree starts at a "root element" 
  and branches from "root element" will have 
  "child elements"

> XML Consists of "Only One" root element which 
  is parent of all other elements

> "child elements" can have "sub elements / child 
   elements"

> Structure
-------------
<root>
  <child>
    <subchild>.....</subchild>
  </child>
</root>

> Example:
-------------
<?xml version="1.0" encoding="UTF-8"?> ====> XML Declaration
<!-- bookstore.xml -->				 ====> XML Comment
<bookstore>							 ====> Root element start-tag 
  <book ISBN="1234">				 ====> Child element start-tag 
                                           with an attribute in 
										   name="value" pair
    <title>Java EE</title>       --
    <author>Praveen D</author>     | ====> Sub elements/Child elements 
    <year>2008</year>              |
    <price>25.99</price>         --
  </book>							====> Child element end-tag

  <book ISBN="5678">			  ====> Second Child element start-tag
    <title>Java</title>
    <author>Keshav</author>
	<author>Madhu</author>
    <year>2009</year>
    <price>19.99</price>
  </book>					      ====> Second Child element end-tag
</bookstore> 					  ====> Root element end-tag 







Entity References
====================
> Some characters have a special meaning in XML

> If you place a character like "<" inside an XML element, 
  it will generate an error because it represents 
  the start of a new element
  
  Ex: <message>salary<1000</message>

> To avoid this error, we can replace the "<" character with
  an "entity reference" as shown below
  
  <message>salary &lt; 1000</message>
  
> There are 5 pre-defined entity references in XML:
	&lt;	<	less than
	&gt;	>	greater than
	&amp;	&	ampersand 
	&apos;	'	apostrophe
	&quot;	"	quotation mark


	
	
	
	

XML Elements
=============
> XML element is everything from (including) the element's 
  start tag to (including) the element's end tag
  
> An element can contain:
  1. text/data
  2. attributes
  3. other elements OR
  4. All of the above
  
> In the above example
  - <title>, <author>, <year>, and <price> have text content
     because they contain text 
  - <bookstore> and <book> have element contents, because 
    they contain elements
  - <book> has an attribute (ISBN="------")

> An element with no content is said to be "empty". In XML, 
  we can indicate an empty element like this
  <element></element>
  OR
  <element />
  
> Empty elements can have attributes <book ISBN="5678" />

> if data present between elemets consist of white spaces 
  then they are considered in XML. However HTML truncates 
  multiple white-spaces to one single white-space

  
  
  
  
  
  
> XML Elements Naming Rules
-----------------------------
  - they are case-sensitive
  - they cannot contain spaces
  - they must start with a letter or underscore
  - they are cannot start with the letters like 
    xml or XML or Xml etc.,
  - they can contain letters, digits, hyphens, underscores, 
    and periods
  - Any name can be used, no words are reserved (except xml)
  
 
> Best Naming Practices
-------------------------
  - Avoid "-"{Check this}
  - Avoid "."
  - Avoid ":"
  - Create descriptive names, like
    <person>, <firstname>, <lastname>
  - Create short and simple names, like 
    <book_title> not like this: <the_title_of_the_book>
  - Non-English letters are perfectly legal in XML but 
    avoid them


  
  
  
  
  
XML Attributes
================
> Like HTML, XML elements can also have attributes

> Attributes are designed to contain data related to a 
  specific element
  
> XML Attributes Must be Quoted either single or double 
  quotes can be used
  
  Ex: <person gender="female">
	   OR
      <person gender='female'>
	
> If the attribute value itself contains double quotes 
  then we can use single quotes
  
  Ex: <person name='Praveen "Bangalore" D'>
	  OR
	  <person name='Praveen &quot;Bangalore&quot; D'>

	
	
	
	
XML Elements Vs Attributes
==============================	
> Example 1 :-
-----------------
<person gender="male">
  <name>Praveen</name>
</person>

> Example 2 :-
-----------------
<person>
  <gender>male</gender>
  <name>Praveen</name>
</person>

> Note: 
--------
In Example 1 gender is an attribute &
In Example 2 gender is an element
Both examples provide the same information

> There are no rules about when to use attributes or 
  when to use elements in XML

When to avoid XML Attributes?
==============================
> attributes cannot contain multiple values but elements can
> attributes cannot contain tree structures but elements can
> attributes are not easily expandable for future changes 
  but elements can

  
  
  
  
  
  
XML Schema's
==================
> W.K.T XML helps us to store & transfer the data

> When sending data from one application to an 
  another, it is essential that both applications 
  have the same "expectations / agreement" about the
  content/data

> for example, A date like "03-11-2004"  
  - in some countries, be interpreted as 3rd November and 
  - in other countries as 11th March
  
> With XML Schemas, the sender application can 
  describe the data in a way that the receiver 
  application will understand

> Schema is nothing but a "Structure". 
  It is a formal description of structure of an XML.
   i.e., 
- which elements are allowed, 
- which elements must be present, 
- which elements are optional, 
- the sequence and relationship of the elements, etc.,

> For example,
- abc@gmail.com is a Valid Email ID. However
- abc#gmail is Invalid because there is "NO @ and ."
- Hence email schema looks somethig like 
  some-name@domain-name.com

> Schema "does not validate the data" instead 
  "it validates the structure"

> There are two ways to define a Schema for XML  
  1. Document Type Definition (DTD)
  2. XML Schema Definition (XSD)


  
  
  
  
1. XML Document Type Definition (DTD)
=======================================
> A DTD defines the structure and the legal elements
  and attributes of an XML document
  
> An application can use a DTD to verify that XML 
  data is valid
  
> There are 2 ways to declare the DTD
  1. An Internal DTD Declaration
  2. An External DTD Declaration

> An Internal DTD Declaration has the following 
  syntax:

	<!DOCTYPE root-element [
	   declarations
	]>
  
> A DTD can also be stored in an external file.
  An XML can reference an external DTD via the 
  following syntax:

   <!DOCTYPE root-element SYSTEM "DTD-filename">
  
  
  
  
  
  
  
  
  
  
2. XML Schema Definition (XSD)
=======================================
> XSD also describes the structure, legal elements 
  and attributes for an XML

> It defines,
- the elements and attributes that can appear in XML
- the number of and also the order of child elements
- data types for elements and attributes
- default and fixed values for elements & attributes

> One of the greatest strength of XML Schemas is 
  the support for data types

> For Example, the following is an example of a date
  declaration in XSD:
  <xs:element name="start-date" type="xs:date"/>
  
  it defines the structure/format of the Date as
  "YYYY-MM-DD"

  An element in XML might look like
  <start-date>2002-09-24</start-date>

> Another great strength about XML Schemas is that 
  they are written in XML
   
> Hence XSD's are extensible so, we can
  -	Reuse Schema in other Schemas
  -	Create your own data types derived from the 
    standard types
  -	Reference multiple schemas in the same document
  
 

NOTE:
=======
> Functionality wise both XSD & DTD similar in nature
  but XSD's are more sophisticated compared to DTD
  
> In otherwords, DTD provides less control on XML 
  structure whereas XSD provides more control
  
> Hence XSD's preferred over DTD's

> Without an XSD/DTD, an XML need only follow the 
  rules for being well-formed 

> With an XSD/DTD, an XML must adhere to additional 
  constraints placed upon the names and values of 
  its elements and attributes in order to be 
  considered valid
  

  
Differences between DTD & XSD
===================================================
|          DTD				|			XSD       |
===================================================
> DTDs are written in Markup Language	
  XSDs are written in XML

> DTD is not extensible
  XSD is extensible

> DTD doesn't support datatypes (limited to text string)
  XSD supports datatypes for elements and attributes
  
> DTD doesn't define order for child elements
  XSD defines order for child elements

> DTD's occurrence indicator is limited to 0, 1 and many; 
  cannot support a specific number such as 8
  
  XSD can support a specific number

> DTD doesn't support namespace
  XSD supports namespace
  
> We canot inherit one DTD into an another 
  We can inherit one XSD into an another 
  
> DTD provides less control on XML structure
  XSD provides more control on XML structure
  

  
  
  
  
  
  
  
  

  
  
  
  
  
  
Parsing XML Documents (XML Parsers)
=========================================
{ Needs Revisiting about the Notes }
> To process the data contained in XML documents,
  we need to write a application program 
 (in any programming language such as Java/C/C++, etc)

> The program makes use of an XML parser to tokenize
  and retrieve the data from the XML documents

> An XML parser is the software that sits between 
 the application and the XML documents to shield 
 the application developer from the details of the
 XML syntax. 

> The parser reads a raw XML document, ensures that 
  is well-formed, and may validate the document 
  against a DTD or XSD

> There are two standard APIs for parsing XML 
  documents:
  1. SAX (Simple API for XML)
  2. DOM (Document Object Model)

> The JAXB provides a common interface for creating, 
  parsing and manipulating XML documents using the 
  standard SAX, DOM and XSLTs
  
  
  
  
  
SAX API 
===========  
> SAX is an event-driven API

> The SAX API defines a number of callback methods,
  which will be called when events occur during 
  parsing

> The SAX parser reads an XML document and generate 
  events as it finds elements, attributes, or data 
  in XML

  
DOM API 
===========  
> DOM is an object-oriented API

> The DOM parser explicitly builds an object model, 
  in the form of a tree structure, to represent an
  XML document

> Our application code can then manipulate the nodes 
  in the tree

> The DOM API defines the mechanism for querying, 
  traversing and manipulating the object model 
  built

  
  


PCDATA : Parsed Character Data
================================
> Text between start-element and end-element is 
  called as PCDATA which will be examined by the 
  parser

Example:-
-----------
<employee>Praveen</employee>
The string "Praveen" is considered as PCDATA


CDATA [Character Data]
============================
> W.K.T special characters (such as "<", "&")
  must be referenced through pre-defined entities

> If XML data contain many special characters, it 
  is cumbersome to replace all of them. Instead we 
  can use "CDATA (character data) section" 
  
> A CDATA section starts with the following sequence:

	<![CDATA[

 and ends with the next occurrence of the sequence:

	]]>

  All characters enclosed between these two sequences
  are interpreted as characters
	
> The XML processor ignores all the markup within the
  CDATA section. 
  
Example : - 
=============

<employee>Praveen</employee>
the start and end "employee" elements are interpreted
as markup. However, if written like this:

<![CDATA[<employee>Praveen</employee>]]>
then the parsers interprets the same as if it had 
been written like this:

&lt;employee&gt;Praveen&lt;/employee&gt;


 


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
https://www3.ntu.edu.sg/home/ehchua/programming/java/j6d_xml.html



eXtensible Markup Language (XML) Continued - Part II :-
===========================================================

	
XML Namespaces
===============

XSLT
=======


XPath
========
	


















Java Architecture for XML Binding (JAXB)
===============================================
> JAXB is part of the JDK (from 1.6 onwards) & "it is
  the most often used API to process XML "
 
> JAXB is a Java API helps us to convert Java Object
  to XML & vice-versa
 
> The Process of converting Java Object to XML 
  is called as "Marshalling" OR "Serialization"
  
> The Process of converting XML to Java Object 
  is called as "Unmarshalling" OR "Deserialization"

> "javax.xml.bind.*" is the package representation 
  of JAXB

> JAXB also helps us to generate XSD using Java
  Objects (with the help of "schemagen" commond)
  
> It helps us to Generate Java Objects using XSD 
  (with the help of "xjc" commond)
  
> The JAX-RS API uses JAXB to convert the XML data 
  from the request into a Java Object & vice-versa

 


 
Commonly Used/Basic Annotations in JAXB
========================================
> W.K.T Java Annotations provide metadata on 
  - packages
  - classes 
  - fields and 
  - methods

> Also each annotation type has its own set of 
  "annotation elements"
  
> JAXB can be used in two ways
- Creating our own Java Beans using JAXB Annotations 
- Generating & Using Java Beans using XSD
  
1. @XmlRootElement
----------------------
> A class that describes an XML element that is to 
  be a top-level element, should be annotated with 
  XmlRootElement
  
> This annotation should be used with a Class Name

> When a top level class is annotated with the 
  @XmlRootElement annotation, then its value is 
  represented as XML element in an XML
  
> It has 2 Optional Annotation Elements
  
  1. name :- 
  ------------
  - Its the name of the XML root element
  - default name is derived from the class name
  
  2. namespace :- 
  ---------------
  - "namespace" name of the XML element
  - default is the empty namespace

2. @XmlElement
---------------
> This annotation helps to define an element 
  in an XML

> This Annotation should be used with Class 
  Variables / Getter Methods

> by default JavaBeans Property Names are used as 
  element names

> the "name" element of this annotation defines 
  name for an Element in XML
						
3. @XmlAttribute 
-------------------
> specifies the attribute for XML element

> This Annotation should be used with Class Variables
  / Getter Methods

> by default JavaBeans Property Names are used as 
  Attribute names

> the "name" element of this annotation defines name
  for an Element in XML

4. @XmlType(propOrder = { "field2", "field1",.. })
----------------------------------------------------
> This annotation should be used with a Class Name

> This annotation with element "propOrder" allows to
  define the order in which the fields are written 
  in an XML file

5. @XmlElementWrapper
----------------------------------------------------
> XmLElementWrapper generates a wrapper element 
  around XML representation

> This is primarily intended to be used to produce 
  a wrapper XML element around collections

> by default JavaBeans Property Names are used as 
  Element Wrapper name

> the "name" element of this annotation defines 
  name for an Element in XML

6. @XmlAccessorType
----------------------
> This annotation defines the way class level 
  anntation needs to be treated
  
- if @XmlAccessorType(XmlAccessType.FIELD) then 
  Class Variables should have JAXB Annotations
  
- if @XmlAccessorType(XmlAccessType.PROPERTY) then 
  Class Getter Methods should have JAXB Annotations
  
- if @XmlAccessorType(XmlAccessType.NONE) then 
  either Class Getter Methods/Class Variables 
  (one of them) should have JAXB Annotations
  
> This annotation should be used with a Class Name 
  along with @XmlRootElement

> If we have JAXB annotations for Class Getter 
  Methods then this annotation can be avioded

JAXB - Generating XSD using JAXB Annotated Class
===================================================
Commond:
------------
schemagen -cp <Class_Files_Location> 
<Java_File_Location_Which_acts_as_Root_Element>

Note:
-------
<Class_Files_Location> should point the begining of 
Package not inside the package

JAXB - Generating Java Beans/POJO's using XSD
===================================================
Commond:
------------
xjc <XSD_File_Location>

Note:
-------
- Generated Classes will be present inside the 
  folder by name "generated"
  
- this folder will be present under the path where 
  we run this commond
  
  Ex:- c:\jaxb>xjc d:\jaxb\schema1.xsd
  
  then "generated" folder along the corresponding 
  classes will be in "c:\jaxb" folder
  
 

JAXB Marshalling [Converting Object into XML]
====================================================
Steps:
--------
1. Create a Java Beans with JAXB annotations 
   or Using XSD generate the classes
2. Create the JAXBContext object
3. Create the Marshaller object
4. Invoke setProperty method on Marshaller object 
   by certain values (Optional)
5. Invoke the marshal method on Marshaller object

JAXB Unmarshalling [Converting XML into Object]
===================================================
Steps:
--------
1. Create a Java Beans with JAXB annotations 
   or Using XSD generate the classes
2. Create the JAXBContext object
3. Create the Unmarshaller object
4. Invoke the unmarshal method
5. Invoke getter methods of Java Bean to access 
   the data

javax.xml.bind.JAXBContext
===============================
> The JAXBContext class provides the client's entry
  point to the JAXB API

> It is an Abstraction layer in JAXB which helps us 
  to perform basic operation of JAXB such as 
  marshal, unmarshal and validate

> Its an abstract class doesnot extend any other 
  JAXB related Class i.e. 
  public abstract class JAXBContext extends Object

> A client application normally obtains 
  new instances of this class using newInstance() 
  method
  
  Syntax:
  --------
	public static JAXBContext 
	newInstance(Class... classesToBeBound)
	throws JAXBException
							   
> There should be ONLY ONE object of "JAXBContext" should exists
  per application. In other words it should be accessed in "Singleton"
  way. NOTE: "JAXBContext" is not Singleton in nature
  
javax.xml.bind.Marshaller
==============================							   
> Marshaller object is responsible for governing
  the process of serializing Java content trees 
  back into XML data
  
> It provides the basic marshalling methods, to 
  convert Java Objects to XML
  
> It's an Interface & an instance of Marshaller is
  obtained by invoking "createMarshaller()" method
  on JAXBContext Object

  Syntax
  -------
  Marshaller JAXBContext.createMarshaller() 
  throws JAXBException
							   


javax.xml.bind.Unmarshaller
==============================
> Unmarshaller object is responsible for governing
  the process of deserializing XML data into newly 
  created Java content trees, optionally validating
  the XML data 
  
> It provides lot of overloaded unmarshalling 
  methods, to convert XML to Java Objects
  
> It's an Interface & an instance of Unmarshaller is
  obtained by invoking "createUnmarshaller()" method
  on JAXBContext Object

  Syntax
  -------
  Unmarshaller JAXBContext.createUnmarshaller() 
  throws JAXBException


Marshalling Example:-
=====================
JAXBContext jaxbContext 
= JAXBContext.newInstance(
    <Class_NM_Which_Represents_XML_Root_Element>);  
  
Marshaller marshaller 
    = jaxbContext.createMarshaller();  

marshaller.marshal(
<Object_Of a Class_Which_Represents_XML_Root_Element>, 
System.out);
  

Unmarshalling Example:-
=====================
JAXBContext jaxbContext 
= JAXBContext.newInstance(
    <Class_NM_Which_Represents_XML_Root_Element>);  
 
Unmarshaller unmarshaller 
= jaxbContext.createUnmarshaller();

Object obj = 
unmarshaller.unmarshal(new FileReader("fileNM.xml"));

JAXB Summary
=====================

I. Annotations Used:
----------------------
1. @XmlRootElement
2. @XmLElement
3. @XmlAttribute
4. @XmLElementWrapper
5. @XmlType
6. @XmlAccessorType


II. Java Classes Used:
----------------------
1. JAXBContext (Abstract Class)
2. Marshaller (Interface)
3. Unmarshaller (Interface)
4. JAXBException (Concreate Class)















*******************************************************************************
AJAX (Asynchronous JavaScript and XML) Histroy: https://en.wikipedia.org/wiki/Ajax_(programming)
* During his time at State Software, Crockford popularized the JSON data format, based upon existing JavaScript language constructs, as a lightweight alternative to XML. He obtained the domain name json.org in 2002, and put up his description of the format there.[9] In July 2006, he specified the format officially, as RFC 4627.[10]*
*******************************************************************************


String str1 = "123praveen200.12";
String str2 = "EmpID=123|EmpNM=praveen|EmpSal=200.12";

<employee>
	<emp-id>123</emp-id>
	<emp-name>Praveen</emp-name>
	<emp-salary>200.12</emp-salary>
</employee>

{"EmpID":123, "EmpNM":"Praveen", "EmpSal":200.12}

JavaScript Object Notation [JSON]
========================================
> Like XML, JSON also is a "Programing Language & 
  Platform Independent Language" which helps to 
  store and transport data

> However compared to XML, its a lightweight, easy 
  for applications to parse and generate by avioding 
  complicated parsing and translations
  
> JSON is a "text format" but uses conventions that
  are familiar to programmers of the C-family of 
  languages (C, C++, C#, Java, JavaScript, Perl, 
  Python, etc.,). Hence JSON is an "ideal data 
  interchange language" 
  
> JSON, as the name implies, which consists of data
  similler to "Object Notation of JavaScript". It's
  an extension of JavaScript scripting language and
  this format was specified by 
  "Douglas Crockford in 2006"
  
> Hence if we receive data from a server in JSON 
  format, we can directly use it like any other 
  JavaScript object

> The filename extension of JSON  ".json"

> MIME type (Content Type) of JSON is 
  "application/json"

JSON Syntax
=================
> JSON syntax is derived from JavaScript object 
  notation syntax:
  - Data is in "name:value" pairs
  - Data is separated by "commas"
  - "Curly braces" hold objects
  - "Square brackets" hold arrays

1. JSON Data
----------------
> JSON data is written as name/value pairs.
  A name/value pair consists of 
  - a field name (in double quotes)
  - followed by a colon
  - followed by a value
  
 Ex:
 ----
 "name" : "Praveen D"
 
 Note:- Name should have double quotes

2. JSON Values
------------------
> In JSON, values must be one of the following 
  data types
  1. String
  2. Number
  3. Boolean
  4. NULL
  5. an Object (JSON object)
  6. an Array

> In JSON, 
  - String values must be written with double quotes
  - Numbers must be an integer/decimal values
  - Boolean values must be true/false
  - JSON NULL values must be null

Ex:-
----
{ "name":"Praveen D", 
  "age":33, 
  "isEmployed":true, 
  "girlFriend":null 
}






3. JSON Objects
-----------------
> Values in JSON can be objects

> JSON Objects are 
  - surrounded by curly braces {}
  - JSON object data is written in "key:value" pairs
  - Each "key:value" pair is separated by a comma
  - Keys must be String and Values must be a valid 
    JSON data type (String, Number, Object, Array, 
	Boolean or null)

  Ex:-
  ----
  {
     "employee":{ "name":"Praveen D", 
				  "age":33, 
				  "isEmployed":true, 
				  "girlFriend":null 
				}
  }
  
> Values in a JSON object can be another JSON object
	{
     "employee": { 
					"name":"Praveen D", 
					"age":33, 
					"isEmployed":true, 
					"girlFriend":null, 
					"cars": {
								"car1":"GM",
								"car2":"BMW",
								"car3":"Audi"
							}
				}
	}

4. JSON Arrays
-----------------
> Values in JSON can be arrays

> JSON Arrays are 
  - surrounded by "Square Brackets []"
  - JSON Arrays values is separated by a comma
  - Array values must be a valid JSON data type 
    (String, Number, Object, Array, Boolean or null)	

> Example 1:-
---------------
{
  "employees":[ "Praveen", "Rekha", "Malleshwar" ]
}

> Example 2:-
---------------
{
  "name":"Praveen",
  "age":33,
  "cars":[ "GM", "BMW", "Audi" ]
}

> Values in an array can also be another array, 
  or even another JSON object:
{
    "name":"Praveen",
    "age":33,
    "cars": [
              { "name":"GM", 
				 "models":[ "Aveo", 
							"Beat", 
							"Cruze" 
						  ] 
			  },
              { "name":"Audi", 
			    "models":[ "A3", "A7" ] 
			  }
            ]
 }
 
JSON vs XML
===============
> Both JSON and XML can be used to store & get the 
  data from a web server
  
> However,
- XML has to be parsed with an XML parser
  JSON can be parsed by a standard JavaScript function
 
- Hence, XML is much more difficult to parse than JSON
  JSON is a ready-to-use JavaScript object

- XML Data cannot consist of Arrays
  JSON Data can consist of Arrays
   
> In General, 
  - Web Applications interact with each other by 
    exchanging data using XML
	
  - Mobile Apps interact with Web Applications by 
    exchanging data using JSON
   
Assignment
================
Create a Java POJO structure for the below XML file
https://maps.googleapis.com/maps/api/geocode/xml?address=bangalore

   
Jackson
=====================   
> Like JAXB,  Jackson is the most often used Framework 
  to process JSON. It helps us to convert Java Object
  to JSON & vice-versa
 
> The Process of converting Java Object to JSON 
  is called as "Marshalling" OR "Serialization"
  
> The Process of converting JSON to Java Object 
  is called as "Unmarshalling" OR "Deserialization"

> "org.codehaus.jackson.*" is the package representation 
  of Jackson

> Glassfish Jersey uses Jackson to convert the JSON data 
  from the request to Java Object & vice-versa

> Jackson is not the only framework to process the JSON 
  but it's one among many. 
  For Ex: GSON, Moxy, JSON-P (part of Java EE) etc.,
  
> However Jackson is a high-performance, efficient and hence 
  very popular JSON processor for Java

> Along with making use of JAXB related annotations Jackson also 
  provides its own set of annotations for mapping too

Processing JSON using Jackson
==================================
> Though there are three different ways to process JSON
  1. Streaming API (It is analogous to SAX parser for XML)
  2. Tree Model (It is analogous to DOM parser for XML)
  3. Data Binding (It converts JSON to and from Java Bean  
      using property accessor or using annotations)
  
> "org.codehaus.jackson.map.ObjectMapper"  its a concreate class
   it helps us to serialize/Marshall and deserialize/Unmarshaller
   regular Java objects (POJOs or Java Beans)

> There should be ONLY ONE object of "ObjectMapper" should exists
  per application. In other words it should be accessed in "Singleton"
  way. NOTE: "ObjectMapper" is not a Singleton Class

> The most commonly used methods of the ObjectMapper are
  1. writeValue()
  2. readValue()
  3. writeValueAsString()
  
> writeValue() Methods
  ---------------------
  - There are various Overloaded Versions writeValue() Methods
     and all of them are Non-Static methods
  - They helps us to convert Java Object to JSON
  - return type of these methods is "void"
  - All of these methods takes Object to be converted as input
    argument (as a 2nd input argument)

> readValue() Methods
  ---------------------
  - There are various Overloaded Versions readValue() Methods
     and all of them are Non-Static methods
  - They helps us to convert JSON to Java Object
  - return type of these methods is "Object of the Desired Class"
  - All of these methods takes JSON (in various forms) as input argument

> writeValueAsString() Method
  ----------------------------
  - It's a Non-Static method
  - It convert Java Object to JSON & return as "String"
 
 
Jackson Marshalling Example :-
===============================
ObjectMapper mapper = new ObjectMapper();
mapper.writeValue(new File("fileNM.json"), <Java_Object_to be_Converted>)

Jackson Unmarshalling Example :-
==================================
ObjectMapper mapper = new ObjectMapper();
Object obj = mapper.readValue(new File("fileNM.json"), <Class_NM>.class)






JAX-RS
============
> JAX-RS stands for JAVA API for RESTful Web Services
> JAX-RS makes it easy for developers to build RESTful web services using the Java programming language
> "javax.ws.rs.*" is the package representation of JAX-RS API
> RESTful web services are loosely coupled, lightweight web services that are particularly well suited for creating APIs for clients spread out across the internet. 
> Representational State Transfer (REST) is an "architectural style" of client-server application centered around the "transfer" of "representations" of "resources" through requests and responses
> In the REST architectural style, data and functionality (i.e. Web Service Methods) are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.
> The representation of that resource might be an XML document, JSON File, an image file, or an HTML page.
> A client might retrieve a particular representation, modify the resource by updating its data, or delete the resource entirely.
> The REST architectural style is designed to use a stateless communication protocol, typically HTTP. 
> The following principles encourage RESTful applications to be simple, lightweight, and fast:
I. Resource identification through URI:
Resources in RESTful web services are identified by URIs
II. Uniform interface: 
Resources are manipulated using a fixed set of four operations
1. create
2. read
3. update
4. delete 
These operations can be perform using below HTTP Methods respectively
1. PUT (creates a new resource)
2. GET (retrieves the current state of a resource in some representation)
3. POST (transfers a new state onto a resource OR Update the existing resource)
4. DELETE (Delete an existing resource)


III. Self-descriptive messages: 
Resources are decoupled from their representation so that their content can be accessed in a variety of formats, such as HTML, XML, plain text, PDF, JPEG, JSON, and other formats.

> The JAX-RS API uses "annotations" to simplify the development of RESTful web services. 
  So Developers 
  - can decorate Java Beans with JAX-RS annotations to define resources and 
  - the actions that can be performed on those resources 

  
  
Summary of JAX-RS Annotations
==================================================================

1. @Path			
-----------
> It identifies the URI path. It can be specified on class or method.
> Avoid using spaces. Instead use underscore (_) or hyphen (-) when using a long resource name. 
  For example, use authorized_users instead of authorized%20users.
> Use lowercase letters. Although URI is case-insensitive, it is a good practice to keep the url in lower case letters only


2. @GET, @POST, @PUT, @DELETE, @HEAD and @OPTIONS
--------------------------------------------------------------------
> This annotations are used with Java Methods
> The Java method annotated with @GET will process HTTP GET requests
> The Java method annotated with @POST will process HTTP POST requests
> The Java method annotated with @PUT will process HTTP PUT requests
> The Java method annotated with @DELETE will process HTTP DELETE requests
> The Java method annotated with @HEAD will process HTTP HEAD requests
> The Java method annotated with @OPTIONS will process HTTP OPTIONS requests
> NOTE: There is NO @TRACE and @CONNECT annotation

3. @PathParam
----------------
> represents the parameter of the URI path

4. @QueryParam
----------------
> represents the parameter of the query string of an URL.


5. @FormParam
---------------
> represents the parameter of the form
> It should not be used with @GET


6. @HeaderParam	
-----------------
> represents the parameter of the header


7. @CookieParam	
------------------
> represents the parameter of the cookie


8. @DefaultValue
---------------------
> Assigns a default value to a parameter passed to the method.


9. @Produces
---------------
> This annotation is used to specify the MIME media types of 
  representations a resource can produce and send back to the client
> For example, "text/plain", "application/json", "application/xml", etc.,


10. @Consumes
---------------
> This annotation is used to specify the MIME media types of representations a resource can consume that were sent by the client.


11. @MatrixParam
-------------------
> Binds the parameter passed to the method to a HTTP matrix parameter in path.					











Jersey RESTful Web Services Framework
=========================================
Jersey RESTful Web Services framework is an open source, production quality, framework for developing RESTful Web Services in Java that provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339) Reference Implementation.

The accepted answer does work, but only if the webapp is deployed to an app server like Glassfish or Wildfly, and possibly servlet containers with EE extensions like TomEE. It doesn't work on standard servlet containers like Tomcat, which I'm sure most people looking for a solution here want to use.

If you're using a standard Tomcat install (or some other servlet container), you need to include a REST implementation since Tomcat doesn't come with one. If you're using Maven, add this to the dependencies section:


REST stands for REpresentational State Transfer. REST is a web standards based architecture and uses HTTP Protocol for data communication. It revolves around resources where every component is a resource and a resource is accessed by a common interface using HTTP standard methods. REST was first introduced by Roy Fielding in year 2000.


In REST architecture, a REST Server simply provides access to resources and the REST client accesses and presents the resources. Here each resource is identified by URIs/ Global IDs. REST uses various representations to represent a resource like Text, JSON and XML. JSON is now the most popular format being used in Web Services.

HTTP Methods
The following HTTP methods are most commonly used in a REST based architecture.

GET âˆ’ Provides a read only access to a resource.

PUT âˆ’ Used to create a new resource.

DELETE âˆ’ Used to remove a resource.

POST âˆ’ Used to update an existing resource or create a new resource.

OPTIONS âˆ’ Used to get the supported operations on a resource



Architecturally, REST doesn't care what the media type is. HTML is just as much a resource representation as anything else. When you click on a link in a browser to visit a static HTML page, that is a "Representational State Transfer".

REST - An Architectural Style, Not a Standard

REST is not a standard. You will not see the W3C putting out a REST specification. You will not see IBM or Microsoft or Sun selling a REST developer's toolkit. Why? Because REST is just an architectural style. You can't bottle up that style. You can only understand it, and design your Web services in that style. (Analogous to the client-server architectural style. There is no client-server standard.)
While REST is not a standard, it does use standards:
HTTP
URL
XML/HTML/GIF/JPEG/etc (Resource Representations)
text/xml, text/html, image/gif, image/jpeg, etc (MIME Types)

REST does not deal with implementation details (e.g., using Java servlets or CGI to implement a Web service)

 REST-compliant Web services allow requesting systems to access and manipulate textual representations of Web resources using a uniform and predefined set of stateless operations.
 
 REST (REpresentational State Transfer) is an architectural style, and an approach to communications that is often used in the development of Web services. The use of REST is often preferred over the more heavyweight SOAP (Simple Object Access Protocol) style because REST does not leverage as much bandwidth, which makes it a better fit for use over the Internet. The SOAP approach requires writing or using a provided server program (to serve data) and a client program (to request data).

 REST, which typically runs over HTTP (Hypertext Transfer Protocol)
 
 The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique Universal Resource Identifiers (URIs). Because each verb has a specific meaning (GET, POST, PUT and DELETE), REST avoids ambiguity.
 
 
 
Jersey RESTful Web Services framework is open source, production quality, framework for developing RESTful Web Services in Java that provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339) Reference Implementation. Jersey framework is more than the JAX-RS Reference Implementation. Jersey provides itâ€™s own API that extend the JAX-RS toolkit with additional features and utilities to further simplify RESTful service and client development.

What is a Resource?
REST architecture treats every content as a resource. These resources can be Text Files, Html Pages, Images, Videos or Dynamic Business Data. REST Server simply provides access to resources and REST client accesses and modifies the resources. Here each resource is identified by URIs/ Global IDs. REST uses various representations to represent a resource where Text, JSON, XML. The most popular representations of resources are XML and JSON.





 
JAX-RS API Annotations
===============================
> JAX-RS API provides following annotations to develop RESTful applications in java. 
> The javax.ws.rs package contains JAX-RS annotations.

No.	Annotation		Description
1.	@Path			

2.	@PathParam		represents the parameter of the URI path.
3.	@GET			specifies method responds to GET request.
4.	@POST			specifies method responds to POST request.
5.	@PUT			specifies method responds to PUT request.
6.	@HEAD			specifies method responds to HEAD request.
7.	@DELETE			specifies method responds to DELETE request.
8.	@OPTIONS		specifies method responds to OPTIONS request.
9.	@FormParam		represents the parameter of the form.
10.	@QueryParam		represents the parameter of the query string of an URL.
11.	@HeaderParam	represents the parameter of the header.
12.	@CookieParam	represents the parameter of the cookie.
13.	@Produces		defines media type for the response such as XML, PLAIN, JSON etc. 
					It defines the media type that the methods of a resource class or 
					MessageBodyWriter can produce.
14.	@Consumes		It defines the media type that the methods of a resource class or 
					MessageBodyReader can produce.

@MatrixParam

Binds the parameter passed to the method to a HTTP matrix parameter in path.					
		

15

@DefaultValue

Assigns a default value to a parameter passed to the method.

16

@Context

Context of the resource. For example, HTTPRequest as a context.		
	


2

@GET

HTTP Get request, used to fetch resource.

3

@PUT

HTTP PUT request, used to create resource.

4

@POST

HTTP POST request, used to create/update resource.

5

@DELETE

HTTP DELETE request, used to delete resource.

6

@HEAD

HTTP HEAD request, used to get status of method availability







	
@Produces("text/plain"): for downloading text file.
@Produces("image/png"): for downloading png image file.
@Produces("application/pdf"): for downloading PDF file.
@Produces("application/vnd.ms-excel"): for downloading excel file.
@Produces("application/msword"): for downloading ms word file.


		





