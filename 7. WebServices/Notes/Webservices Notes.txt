Web Services Introduction
============================
> Servlets, JSP along with JDBC helps to develop 
  Web Application

> However "Web Services" a.k.a "Application Services"
  helps web applications to interact with any other 
  applications (Mobile Apps / Desktop Applications 
  / Web Applications)

> Web Services, as name implies, they are the 
  services avilable in "Web". They take the request 
  from Applications, via any communication protocol such
  as HTTP & generate Response

> Web Services, is a concept, are independent of
  - Platform
  - Programing Languages &
  - Applications
  
> Web Services take Web-applications to the 
  Next Level!!!

> Unlike Web Applications, Web Services do not 
  provide the user with a GUI. 
  
> In other words Web services are meant for 
  "Inter-System Communication
  / Application-to-Application Interactions but not
  for Users"
  
> Hence Web Services do not require the use of 
  browsers or HTML
 
> Few real time examples of Web Services
  - Mobile Apps (ex: GMail App) communicate with 
    their correspondig Web Applications (ex: GMail) 
    using Web Services
	
  - Uber / OLA Mobile Apps/Web Application interact 
    with Google Maps using Web Services
	
  - BookMyShow Web Application / Mobile Application 
    interact with PVR Web Application using Web   
    Services   
 
 
 
 
 
> Web Service has two participants:
  1. Service Provider / Producer
  2. Service Consumer / Requester
  
> Service Provider exposes the "Service on Web" &  
  Service Consumer uses this "Web Service"

> Service Provider should be a Web Application, however  
  Service Consumer can be Desktop/Mobile Application or Web Application

> There are 2 types of Web Services
  1. RESTful Web Services
  2. SOAP Web Services / XML Web Services 

> Java provides 2 API's to develop these web services
  1. "JAX-RS" API for developing 
	  "RESTful Web Services"
	  
  2. "JAX-WS" API for developing 
      "SOAP Web Services"

> "javax.ws.rs.*" is the package representation 
  of JAX-RS API  
  
  "javax.jws.*" is the package representation 
  of JAX-WS API  
  
  
  
Why Web Services / Advantages of Web Services
==============================================

1. Web Services Interoperability (WS-I)
------------------------------------------
> Web Services are "Application, Platform and 
  Technology Independent"
  
> Ex: VB / .NET applications can talk to Java Web 
  Services and vice versa. Thus helping the 
  organisations to use existing applications which 
  are developed using other technologies 
  (may be legacy) 

> Also Web Services helps/allows different applications to 
  share data among themselves

> Ex: Uber / OLA and Google Maps shares the data 
      among each other

	  
	  
	  
2. Loosely Coupled 
------------------------
> Each application is independent of one another. 
  Hence changes done to one application will not 
  impact the "unrelated areas"
  
> Ex: Changes / Modifications done at Uber / OLA 
      will not impact Google Maps

  
3. No need of re-inventing the wheel
-------------------------------------
> Web Services reduces the software development time
 
> This helps the other business partners to quickly 
  develop application and start doing business
  
> This helps business to save time and money by 
  cutting development time

Ex: Uber / OLA can make use of Google Maps 


4. Business Opportunity
-----------------------
> Web Services will open the door for new business 
  opportunities by making it easy to connect with 
  partners

> Ex: Domino's can get the order from Food Panda / 
      Swiggy along with getting orders from its 
	  own site 

	  
	  

5. Service Reuse
------------------
> Web Services takes code reuse a step further

> A specific service within the organisation is 
  only coded once and used over and over again by 
  other applications
  
> Ex: An organization can have a "Single Payment 
     Gateway service" which helps other web 
	 applications of that organization to interact 
	 with "Payment Gateways" 


	 
Web Services Architecture
===========================
NOTE:
-----
> Web Service Producer MUST be a Web Application
> However Web Service Consumer can be 
  - Web Application OR
  - Desktop Application OR
  - Mobile Application




Steps Followed to Create the 
First Web Service Producer & Consumer Web Applications
==============================================================================================

I. Steps for Web Service "Producer Web Application"
---------------------------------------------------
1. Created the Maven Project by providing the below 
   information
   
   Archetype 	: maven-archetype-webapp
   Group ID	 	: com.google
   Artifact ID	: googlemaps
   
2. Under Java Resources if "src/main/java" folder is not
   present then, create it
   
3. Added the "Glassfish Jersey & Servlet" Dependencies to
   pom.xml    

4. Configured Jersey "ServletContainer" in web.xml 

5. Created the Java Class which hosts the Rest 
   Webservices using Jersey Framework


II. Steps for Web Service Consumer Web Application
-----------------------------------------------------

1. Created the Maven Project by providing the below 
   information
   
   Archetype 	: maven-archetype-webapp
   Group ID	 	: org.jspiders
   Artifact ID	: mywebapp

2. Under Java Resources if "src/main/java" folder is not
   present then, create it

3. Added the "Glassfish Jersey & Servlet" Dependencies to
   pom.xml    
   
3. Created the Servlet which interact with above 
   web application to consume the Web Services

4. Configured this Servlet in web.xml 

Maven Dependencies
=======================
> URL to get the Dependencies : 
  https://mvnrepository.com/
  
> Jersey Dependencies	:
	jersey-client
	jersey-server
	jersey-container-servlet
	jersey-media-json-jackson
	jersey-common
	jersey-media-multipart
	jersey-container-servlet-core
	
> Servelet Dependency	:
	javax.servlet-api

	
	

Maven Installation Steps 
===========================================================

Pre-requirement :
------------------ 
JDK is Required & JAVA_HOME environment variable 
should be set

Steps
---------
1. Download Maven Binary from Apache Maven
2. Set the Following environment Variables
   - M2_HOME (Its the latest variable)
   - MAVEN_HOME (Some applications stil refer this variable)
   - Modify path variable to add %M2_HOME%/bin
3. run mvn in commond 

	
Data Formats
==============
> W.K.T Web Services helps different applications to interact
  with Web Applications

> In this interactions there should be a exchange of Data & that
  data should have some specific format
  
> The most commonly used Data formats are
  1. XML
  2. JSON  
	
	
	
eXtensible Markup Language (XML) - Part I:-
==================================================
> XML is "Programing Language & Platform Independent 
  Language" which helps to store and transport data

> Different Applications which are developed using 
  different technologies can Transfer the Data among
  themselves with the help of XML

> As the name implies it's an extension of HTML & 
  hence XML looks similar to HTML but it’s not a HTML

> XML has User-defind Tags. XML tags are also called
  as "elements"

> XML Elements are "Case Sensitive"

> XML is "Strictly Typed" Language & Hence every 
  opening element should have corresponding closing 
  element and also XML elements Must be Properly 
  Nested/closed
  
  Ex: <employee>
			<name>Praveen</name>
	   </employee>
  
  Note:- 
  - In the above example first you should closed
    </name> & then </employee> but 
  
  - In HTML its not mandatory. For example, 
    <B><U><I>My Text</U></I></B> works perfectly fine
  
> Below line is called as "XML prolog", which is 
  optional. If it exists, it must be the First Line 
  of XML  
  <?xml version="1.0" encoding="UTF-8" ?>

> The syntax of XML comment is similar to that of HTML
  <!-- This is a comment -->
  
> File extension of XML is ".xml"  
  
> MIME type (Content Type) of XML is "application/xml"   

   
   
   
   
   
XML Structure
================
> Like HTML, XML follows a Tree Structure

> An XML tree starts at a "root element" 
  and branches from "root element" will have 
  "child elements"

> XML Consists of "Only One" root element which 
  is parent of all other elements

> "child elements" can have "sub elements / child 
   elements"

> Structure
-------------
<root>
  <child>
    <subchild>.....</subchild>
  </child>
</root>

> Example:
-------------
<?xml version="1.0" encoding="UTF-8"?> ====> XML Declaration
<!-- bookstore.xml -->				 ====> XML Comment
<bookstore>							 ====> Root element start-tag 
  <book ISBN="1234">				 ====> Child element start-tag 
                                           with an attribute in 
										   name="value" pair
    <title>Java EE</title>       --
    <author>Praveen D</author>     | ====> Sub elements/Child elements 
    <year>2008</year>              |
    <price>25.99</price>         --
  </book>							====> Child element end-tag

  <book ISBN="5678">			  ====> Second Child element start-tag
    <title>Java</title>
    <author>Keshav</author>
	<author>Madhu</author>
    <year>2009</year>
    <price>19.99</price>
  </book>					      ====> Second Child element end-tag
</bookstore> 					  ====> Root element end-tag 







Entity References
====================
> Some characters have a special meaning in XML

> If you place a character like "<" inside an XML element, 
  it will generate an error because it represents 
  the start of a new element
  
  Ex: <message>salary<1000</message>

> To avoid this error, we can replace the "<" character with
  an "entity reference" as shown below
  
  <message>salary &lt; 1000</message>
  
> There are 5 pre-defined entity references in XML:
	&lt;	<	less than
	&gt;	>	greater than
	&amp;	&	ampersand 
	&apos;	'	apostrophe
	&quot;	"	quotation mark


	
	
	
	

XML Elements
=============
> XML element is everything from (including) the element's 
  start tag to (including) the element's end tag
  
> An element can contain:
  1. text/data
  2. attributes
  3. other elements OR
  4. All of the above
  
> In the above example
  - <title>, <author>, <year>, and <price> have text content
     because they contain text 
  - <bookstore> and <book> have element contents, because 
    they contain elements
  - <book> has an attribute (ISBN="------")

> An element with no content is said to be "empty". In XML, 
  we can indicate an empty element like this
  <element></element>
  OR
  <element />
  
> Empty elements can have attributes <book ISBN="5678" />

> if data present between elemets consist of white spaces 
  then they are considered in XML. However HTML truncates 
  multiple white-spaces to one single white-space

  
  
  
  
  
  
> XML Elements Naming Rules
-----------------------------
  - they are case-sensitive
  - they cannot contain spaces
  - they must start with a letter or underscore
  - they are cannot start with the letters like 
    xml or XML or Xml etc.,
  - they can contain letters, digits, hyphens, underscores, 
    and periods
  - Any name can be used, no words are reserved (except xml)
  
 
> Best Naming Practices
-------------------------
  - Avoid "-"{Check this}
  - Avoid "."
  - Avoid ":"
  - Create descriptive names, like
    <person>, <firstname>, <lastname>
  - Create short and simple names, like 
    <book_title> not like this: <the_title_of_the_book>
  - Non-English letters are perfectly legal in XML but 
    avoid them


  
  
  
  
  
XML Attributes
================
> Like HTML, XML elements can also have attributes

> Attributes are designed to contain data related to a 
  specific element
  
> XML Attributes Must be Quoted either single or double 
  quotes can be used
  
  Ex: <person gender="female">
	   OR
      <person gender='female'>
	
> If the attribute value itself contains double quotes 
  then we can use single quotes
  
  Ex: <person name='Praveen "Bangalore" D'>
	  OR
	  <person name='Praveen &quot;Bangalore&quot; D'>

	
	
	
	
XML Elements Vs Attributes
==============================	
> Example 1 :-
-----------------
<person gender="male">
  <name>Praveen</name>
</person>

> Example 2 :-
-----------------
<person>
  <gender>male</gender>
  <name>Praveen</name>
</person>

> Note: 
--------
In Example 1 gender is an attribute &
In Example 2 gender is an element
Both examples provide the same information

> There are no rules about when to use attributes or 
  when to use elements in XML

When to avoid XML Attributes?
==============================
> attributes cannot contain multiple values but elements can
> attributes cannot contain tree structures but elements can
> attributes are not easily expandable for future changes 
  but elements can

  
  
  
  
  
  
XML Schema's
==================
> W.K.T XML helps us to store & transfer the data

> When sending data from one application to an 
  another, it is essential that both applications 
  have the same "expectations / agreement" about the
  content/data

> for example, A date like "03-11-2004"  
  - in some countries, be interpreted as 3rd November and 
  - in other countries as 11th March
  
> With XML Schemas, the sender application can 
  describe the data in a way that the receiver 
  application will understand

> Schema is nothing but a "Structure". 
  It is a formal description of structure of an XML.
   i.e., 
- which elements are allowed, 
- which elements must be present, 
- which elements are optional, 
- the sequence and relationship of the elements, etc.,

> For example,
- abc@gmail.com is a Valid Email ID. However
- abc#gmail is Invalid because there is "NO @ and ."
- Hence email schema looks somethig like 
  some-name@domain-name.com

> Schema "does not validate the data" instead 
  "it validates the structure"

> There are two ways to define a Schema for XML  
  1. Document Type Definition (DTD)
  2. XML Schema Definition (XSD)


  
  
  
  
1. XML Document Type Definition (DTD)
=======================================
> A DTD defines the structure and the legal elements
  and attributes of an XML document
  
> An application can use a DTD to verify that XML 
  data is valid
  
> There are 2 ways to declare the DTD
  1. An Internal DTD Declaration
  2. An External DTD Declaration

> An Internal DTD Declaration has the following 
  syntax:

	<!DOCTYPE root-element [
	   declarations
	]>
  
> A DTD can also be stored in an external file.
  An XML can reference an external DTD via the 
  following syntax:

   <!DOCTYPE root-element SYSTEM "DTD-filename">
  
  
  
  
  
  
  
  
  
  
2. XML Schema Definition (XSD)
=======================================
> XSD also describes the structure, legal elements 
  and attributes for an XML

> It defines,
- the elements and attributes that can appear in XML
- the number of and also the order of child elements
- data types for elements and attributes
- default and fixed values for elements & attributes

> One of the greatest strength of XML Schemas is 
  the support for data types

> For Example, the following is an example of a date
  declaration in XSD:
  <xs:element name="start-date" type="xs:date"/>
  
  it defines the structure/format of the Date as
  "YYYY-MM-DD"

  An element in XML might look like
  <start-date>2002-09-24</start-date>

> Another great strength about XML Schemas is that 
  they are written in XML
   
> Hence XSD's are extensible so, we can
  -	Reuse Schema in other Schemas
  -	Create your own data types derived from the 
    standard types
  -	Reference multiple schemas in the same document
  
 

NOTE:
=======
> Functionality wise both XSD & DTD similar in nature
  but XSD's are more sophisticated compared to DTD
  
> In otherwords, DTD provides less control on XML 
  structure whereas XSD provides more control
  
> Hence XSD's preferred over DTD's

> Without an XSD/DTD, an XML need only follow the 
  rules for being well-formed 

> With an XSD/DTD, an XML must adhere to additional 
  constraints placed upon the names and values of 
  its elements and attributes in order to be 
  considered valid
  

  
Differences between DTD & XSD
===================================================
|          DTD				|			XSD       |
===================================================
> DTDs are written in Markup Language	
  XSDs are written in XML

> DTD is not extensible
  XSD is extensible

> DTD doesn't support datatypes (limited to text string)
  XSD supports datatypes for elements and attributes
  
> DTD doesn't define order for child elements
  XSD defines order for child elements

> DTD's occurrence indicator is limited to 0, 1 and many; 
  cannot support a specific number such as 8
  
  XSD can support a specific number

> DTD doesn't support namespace
  XSD supports namespace
  
> We canot inherit one DTD into an another 
  We can inherit one XSD into an another 
  
> DTD provides less control on XML structure
  XSD provides more control on XML structure
  

  
  
  
  
  
  
  
  

  
  
  
  
  
  
Parsing XML Documents (XML Parsers)
=========================================
{ Needs Revisiting about the Notes }
> To process the data contained in XML documents,
  we need to write a application program 
 (in any programming language such as Java/C/C++, etc)

> The program makes use of an XML parser to tokenize
  and retrieve the data from the XML documents

> An XML parser is the software that sits between 
 the application and the XML documents to shield 
 the application developer from the details of the
 XML syntax. 

> The parser reads a raw XML document, ensures that 
  is well-formed, and may validate the document 
  against a DTD or XSD

> There are two standard APIs for parsing XML 
  documents:
  1. SAX (Simple API for XML)
  2. DOM (Document Object Model)

> The JAXB provides a common interface for creating, 
  parsing and manipulating XML documents using the 
  standard SAX, DOM and XSLTs
  
  
  
  
  
SAX API 
===========  
> SAX is an event-driven API

> The SAX API defines a number of callback methods,
  which will be called when events occur during 
  parsing

> The SAX parser reads an XML document and generate 
  events as it finds elements, attributes, or data 
  in XML

  
DOM API 
===========  
> DOM is an object-oriented API

> The DOM parser explicitly builds an object model, 
  in the form of a tree structure, to represent an
  XML document

> Our application code can then manipulate the nodes 
  in the tree

> The DOM API defines the mechanism for querying, 
  traversing and manipulating the object model 
  built

  
  


PCDATA : Parsed Character Data
================================
> Text between start-element and end-element is 
  called as PCDATA which will be examined by the 
  parser

Example:-
-----------
<employee>Praveen</employee>
The string "Praveen" is considered as PCDATA


CDATA [Character Data]
============================
> W.K.T special characters (such as "<", "&")
  must be referenced through pre-defined entities

> If XML data contain many special characters, it 
  is cumbersome to replace all of them. Instead we 
  can use "CDATA (character data) section" 
  
> A CDATA section starts with the following sequence:

	<![CDATA[

 and ends with the next occurrence of the sequence:

	]]>

  All characters enclosed between these two sequences
  are interpreted as characters
	
> The XML processor ignores all the markup within the
  CDATA section. 
  
Example : - 
=============

<employee>Praveen</employee>
the start and end "employee" elements are interpreted
as markup. However, if written like this:

<![CDATA[<employee>Praveen</employee>]]>
then the parsers interprets the same as if it had 
been written like this:

&lt;employee&gt;Praveen&lt;/employee&gt;


 


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
https://www3.ntu.edu.sg/home/ehchua/programming/java/j6d_xml.html



eXtensible Markup Language (XML) Continued - Part II :-
===========================================================

	
XML Namespaces
===============

XSLT
=======


XPath
========
	


















Java Architecture for XML Binding (JAXB)
===============================================
> JAXB is part of the JDK (from 1.6 onwards) & "it is
  the most often used API to process XML "
 
> JAXB is a Java API helps us to convert Java Object
  to XML & vice-versa
 
> The Process of converting Java Object to XML 
  is called as "Marshalling" OR "Serialization"
  
> The Process of converting XML to Java Object 
  is called as "Unmarshalling" OR "Deserialization"

> "javax.xml.bind.*" is the package representation 
  of JAXB

> JAXB also helps us to generate XSD using Java
  Objects (with the help of "schemagen" commond)
  
> It helps us to Generate Java Objects using XSD 
  (with the help of "xjc" commond)
  
> The JAX-RS API uses JAXB to convert the XML data 
  from the request into a Java Object & vice-versa

 


 
Commonly Used/Basic Annotations in JAXB
========================================
> W.K.T Java Annotations provide metadata on 
  - packages
  - classes 
  - fields and 
  - methods

> Also each annotation type has its own set of 
  "annotation elements"
  
> JAXB can be used in two ways
- Creating our own Java Beans using JAXB Annotations 
- Generating & Using Java Beans using XSD
  
1. @XmlRootElement
----------------------
> A class that describes an XML element that is to 
  be a top-level element, should be annotated with 
  XmlRootElement
  
> This annotation should be used with a Class Name

> When a top level class is annotated with the 
  @XmlRootElement annotation, then its value is 
  represented as XML element in an XML
  
> It has 2 Optional Annotation Elements
  
  1. name :- 
  ------------
  - Its the name of the XML root element
  - default name is derived from the class name
  
  2. namespace :- 
  ---------------
  - "namespace" name of the XML element
  - default is the empty namespace

2. @XmlElement
---------------
> This annotation helps to define an element 
  in an XML

> This Annotation should be used with Class 
  Variables / Getter Methods

> by default JavaBeans Property Names are used as 
  element names

> the "name" element of this annotation defines 
  name for an Element in XML
						
3. @XmlAttribute 
-------------------
> specifies the attribute for XML element

> This Annotation should be used with Class Variables
  / Getter Methods

> by default JavaBeans Property Names are used as 
  Attribute names

> the "name" element of this annotation defines name
  for an Element in XML

4. @XmlType(propOrder = { "field2", "field1",.. })
----------------------------------------------------
> This annotation should be used with a Class Name

> This annotation with element "propOrder" allows to
  define the order in which the fields are written 
  in an XML file

5. @XmlElementWrapper
----------------------------------------------------
> XmLElementWrapper generates a wrapper element 
  around XML representation

> This is primarily intended to be used to produce 
  a wrapper XML element around collections

> by default JavaBeans Property Names are used as 
  Element Wrapper name

> the "name" element of this annotation defines 
  name for an Element in XML

6. @XmlAccessorType
----------------------
> This annotation defines the way class level 
  anntation needs to be treated
  
- if @XmlAccessorType(XmlAccessType.FIELD) then 
  Class Variables should have JAXB Annotations
  
- if @XmlAccessorType(XmlAccessType.PROPERTY) then 
  Class Getter Methods should have JAXB Annotations
  
- if @XmlAccessorType(XmlAccessType.NONE) then 
  either Class Getter Methods/Class Variables 
  (one of them) should have JAXB Annotations
  
> This annotation should be used with a Class Name 
  along with @XmlRootElement

> If we have JAXB annotations for Class Getter 
  Methods then this annotation can be avioded

JAXB - Generating XSD using JAXB Annotated Class
===================================================
Commond:
------------
schemagen -cp <Class_Files_Location> 
<Java_File_Location_Which_acts_as_Root_Element>

Note:
-------
<Class_Files_Location> should point the begining of 
Package not inside the package

JAXB - Generating Java Beans/POJO's using XSD
===================================================
Commond:
------------
xjc <XSD_File_Location>

Note:
-------
- Generated Classes will be present inside the 
  folder by name "generated"
  
- this folder will be present under the path where 
  we run this commond
  
  Ex:- c:\jaxb>xjc d:\jaxb\schema1.xsd
  
  then "generated" folder along the corresponding 
  classes will be in "c:\jaxb" folder
  
 

JAXB Marshalling [Converting Object into XML]
====================================================
Steps:
--------
1. Create a Java Beans with JAXB annotations 
   or Using XSD generate the classes
2. Create the JAXBContext object
3. Create the Marshaller object
4. Invoke setProperty method on Marshaller object 
   by certain values (Optional)
5. Invoke the marshal method on Marshaller object

JAXB Unmarshalling [Converting XML into Object]
===================================================
Steps:
--------
1. Create a Java Beans with JAXB annotations 
   or Using XSD generate the classes
2. Create the JAXBContext object
3. Create the Unmarshaller object
4. Invoke the unmarshal method
5. Invoke getter methods of Java Bean to access 
   the data

javax.xml.bind.JAXBContext
===============================
> The JAXBContext class provides the client's entry
  point to the JAXB API

> It is an Abstraction layer in JAXB which helps us 
  to perform basic operation of JAXB such as 
  marshal, unmarshal and validate

> Its an abstract class doesnot extend any other 
  JAXB related Class i.e. 
  public abstract class JAXBContext extends Object

> A client application normally obtains 
  new instances of this class using newInstance() 
  method
  
  Syntax:
  --------
	public static JAXBContext 
	newInstance(Class... classesToBeBound)
	throws JAXBException
							   
> There should be ONLY ONE object of "JAXBContext" should exists
  per application. In other words it should be accessed in "Singleton"
  way. NOTE: "JAXBContext" is not Singleton in nature
  
javax.xml.bind.Marshaller
==============================							   
> Marshaller object is responsible for governing
  the process of serializing Java content trees 
  back into XML data
  
> It provides the basic marshalling methods, to 
  convert Java Objects to XML
  
> It's an Interface & an instance of Marshaller is
  obtained by invoking "createMarshaller()" method
  on JAXBContext Object

  Syntax
  -------
  Marshaller JAXBContext.createMarshaller() 
  throws JAXBException
							   


javax.xml.bind.Unmarshaller
==============================
> Unmarshaller object is responsible for governing
  the process of deserializing XML data into newly 
  created Java content trees, optionally validating
  the XML data 
  
> It provides lot of overloaded unmarshalling 
  methods, to convert XML to Java Objects
  
> It's an Interface & an instance of Unmarshaller is
  obtained by invoking "createUnmarshaller()" method
  on JAXBContext Object

  Syntax
  -------
  Unmarshaller JAXBContext.createUnmarshaller() 
  throws JAXBException


Marshalling Example:-
=====================
JAXBContext jaxbContext 
= JAXBContext.newInstance(
    <Class_NM_Which_Represents_XML_Root_Element>);  
  
Marshaller marshaller 
    = jaxbContext.createMarshaller();  

marshaller.marshal(
<Object_Of a Class_Which_Represents_XML_Root_Element>, 
System.out);
  

Unmarshalling Example:-
=====================
JAXBContext jaxbContext 
= JAXBContext.newInstance(
    <Class_NM_Which_Represents_XML_Root_Element>);  
 
Unmarshaller unmarshaller 
= jaxbContext.createUnmarshaller();

Object obj = 
unmarshaller.unmarshal(new FileReader("fileNM.xml"));

JAXB Summary
=====================

I. Annotations Used:
----------------------
1. @XmlRootElement
2. @XmLElement
3. @XmlAttribute
4. @XmLElementWrapper
5. @XmlType
6. @XmlAccessorType


II. Java Classes Used:
----------------------
1. JAXBContext (Abstract Class)
2. Marshaller (Interface)
3. Unmarshaller (Interface)
4. JAXBException (Concreate Class)















*******************************************************************************
AJAX (Asynchronous JavaScript and XML) Histroy: https://en.wikipedia.org/wiki/Ajax_(programming)
* During his time at State Software, Crockford popularized the JSON data format, based upon existing JavaScript language constructs, as a lightweight alternative to XML. He obtained the domain name json.org in 2002, and put up his description of the format there.[9] In July 2006, he specified the format officially, as RFC 4627.[10]*
*******************************************************************************


String str1 = "123praveen200.12";
String str2 = "EmpID=123|EmpNM=praveen|EmpSal=200.12";

<employee>
	<emp-id>123</emp-id>
	<emp-name>Praveen</emp-name>
	<emp-salary>200.12</emp-salary>
</employee>

{"EmpID":123, "EmpNM":"Praveen", "EmpSal":200.12}

JavaScript Object Notation [JSON]
========================================
> Like XML, JSON also is a "Programing Language & 
  Platform Independent Language" which helps to 
  store and transport data

> However compared to XML, its a lightweight, easy 
  for applications to parse and generate by avioding 
  complicated parsing and translations
  
> JSON is a "text format" but uses conventions that
  are familiar to programmers of the C-family of 
  languages (C, C++, C#, Java, JavaScript, Perl, 
  Python, etc.,). Hence JSON is an "ideal data 
  interchange language" 
  
> JSON, as the name implies, which consists of data
  similler to "Object Notation of JavaScript". It's
  an extension of JavaScript scripting language and
  this format was specified by 
  "Douglas Crockford in 2006"
  
> Hence if we receive data from a server in JSON 
  format, we can directly use it like any other 
  JavaScript object

> The filename extension of JSON  ".json"

> MIME type (Content Type) of JSON is 
  "application/json"

JSON Syntax
=================
> JSON syntax is derived from JavaScript object 
  notation syntax:
  - Data is in "name:value" pairs
  - Data is separated by "commas"
  - "Curly braces" hold objects
  - "Square brackets" hold arrays

1. JSON Data
----------------
> JSON data is written as name/value pairs.
  A name/value pair consists of 
  - a field name (in double quotes)
  - followed by a colon
  - followed by a value
  
 Ex:
 ----
 "name" : "Praveen D"
 
 Note:- Name should have double quotes

2. JSON Values
------------------
> In JSON, values must be one of the following 
  data types
  1. String
  2. Number
  3. Boolean
  4. NULL
  5. an Object (JSON object)
  6. an Array

> In JSON, 
  - String values must be written with double quotes
  - Numbers must be an integer/decimal values
  - Boolean values must be true/false
  - JSON NULL values must be null

Ex:-
----
{ "name":"Praveen D", 
  "age":33, 
  "isEmployed":true, 
  "girlFriend":null 
}






3. JSON Objects
-----------------
> Values in JSON can be objects

> JSON Objects are 
  - surrounded by curly braces {}
  - JSON object data is written in "key:value" pairs
  - Each "key:value" pair is separated by a comma
  - Keys must be String and Values must be a valid 
    JSON data type (String, Number, Object, Array, 
	Boolean or null)

  Ex:-
  ----
  {
     "employee":{ "name":"Praveen D", 
				  "age":33, 
				  "isEmployed":true, 
				  "girlFriend":null 
				}
  }
  
> Values in a JSON object can be another JSON object
	{
     "employee": { 
					"name":"Praveen D", 
					"age":33, 
					"isEmployed":true, 
					"girlFriend":null, 
					"cars": {
								"car1":"GM",
								"car2":"BMW",
								"car3":"Audi"
							}
				}
	}

4. JSON Arrays
-----------------
> Values in JSON can be arrays

> JSON Arrays are 
  - surrounded by "Square Brackets []"
  - JSON Arrays values is separated by a comma
  - Array values must be a valid JSON data type 
    (String, Number, Object, Array, Boolean or null)	

> Example 1:-
---------------
{
  "employees":[ "Praveen", "Rekha", "Malleshwar" ]
}

> Example 2:-
---------------
{
  "name":"Praveen",
  "age":33,
  "cars":[ "GM", "BMW", "Audi" ]
}

> Values in an array can also be another array, 
  or even another JSON object:
{
    "name":"Praveen",
    "age":33,
    "cars": [
              { "name":"GM", 
				 "models":[ "Aveo", 
							"Beat", 
							"Cruze" 
						  ] 
			  },
              { "name":"Audi", 
			    "models":[ "A3", "A7" ] 
			  }
            ]
 }
 
JSON vs XML
===============
> Both JSON and XML can be used to store & get the 
  data from a web server
  
> However,
- XML has to be parsed with an XML parser
  JSON can be parsed by a standard JavaScript function
 
- Hence, XML is much more difficult to parse than JSON
  JSON is a ready-to-use JavaScript object

- XML Data cannot consist of Arrays
  JSON Data can consist of Arrays
   
> In General, 
  - Web Applications interact with each other by 
    exchanging data using XML
	
  - Mobile Apps interact with Web Applications by 
    exchanging data using JSON
   
Assignment
================
Create a Java POJO structure for the below XML file
https://maps.googleapis.com/maps/api/geocode/xml?address=bangalore

   
Jackson
=====================   
> Like JAXB,  Jackson is the most often used Framework 
  to process JSON. It helps us to convert Java Object
  to JSON & vice-versa
 
> The Process of converting Java Object to JSON 
  is called as "Marshalling" OR "Serialization"
  
> The Process of converting JSON to Java Object 
  is called as "Unmarshalling" OR "Deserialization"

> "org.codehaus.jackson.*" is the package representation 
  of Jackson

> Glassfish Jersey uses Jackson to convert the JSON data 
  from the request to Java Object & vice-versa

> Jackson is not the only framework to process the JSON 
  but it's one among many. 
  For Ex: GSON, Moxy, JSON-P (part of Java EE) etc.,
  
> However Jackson is a high-performance, efficient and hence 
  very popular JSON processor for Java

> Along with making use of JAXB related annotations Jackson also 
  provides its own set of annotations for mapping too

Processing JSON using Jackson
==================================
> Though there are three different ways to process JSON
  1. Streaming API (It is analogous to SAX parser for XML)
  2. Tree Model (It is analogous to DOM parser for XML)
  3. Data Binding (It converts JSON to and from Java Bean  
      using property accessor or using annotations)
  
> "org.codehaus.jackson.map.ObjectMapper"  its a concreate class
   it helps us to serialize/Marshall and deserialize/Unmarshaller
   regular Java objects (POJOs or Java Beans)

> There should be ONLY ONE object of "ObjectMapper" should exists
  per application. In other words it should be accessed in "Singleton"
  way. NOTE: "ObjectMapper" is not a Singleton Class

> The most commonly used methods of the ObjectMapper are
  1. writeValue()
  2. readValue()
  3. writeValueAsString()
  
> writeValue() Methods
  ---------------------
  - There are various Overloaded Versions writeValue() Methods
     and all of them are Non-Static methods
  - They helps us to convert Java Object to JSON
  - return type of these methods is "void"
  - All of these methods takes Object to be converted as input
    argument (as a 2nd input argument)

> readValue() Methods
  ---------------------
  - There are various Overloaded Versions readValue() Methods
     and all of them are Non-Static methods
  - They helps us to convert JSON to Java Object
  - return type of these methods is "Object of the Desired Class"
  - All of these methods takes JSON (in various forms) as input argument

> writeValueAsString() Method
  ----------------------------
  - It's a Non-Static method
  - It convert Java Object to JSON & return as "String"
 
 
Jackson Marshalling Example :-
===============================
ObjectMapper mapper = new ObjectMapper();
mapper.writeValue(new File("fileNM.json"), <Java_Object_to be_Converted>)

Jackson Unmarshalling Example :-
==================================
ObjectMapper mapper = new ObjectMapper();
Object obj = mapper.readValue(new File("fileNM.json"), <Class_NM>.class)


Representational State Transfer (REST) Web Services
============================================================
> It's an "architectural style" of client-server application, centered around  
  the "transfer" of "representations" of "resources" through requests and responses

> In the REST architectural style, data and functionality (i.e. Web Service Methods) 
  are considered as resources and are accessed using Uniform Resource Identifiers (URIs), 
  typically hyperlinks on the Web
  
> The representation of that resource might be 
  - an XML document
  - a JSON File
  - a Simple Text
  - an image file  
  - an HTML page, etc.,
  
> A client application might 
  - retrieve a particular representation
  - modify the resource by updating its data or 
  - delete the resource entirely

> The REST architectural style is designed to use a stateless 
  communication protocol, typically HTTP
  
> The following principles encourage RESTful applications 
  to be simple, lightweight, and fast
  
  I. Resource Identification through URI:-
  -----------------------------------------
  Resources in RESTful web services are identified by URIs
 
  II. Uniform Interface:-
  ---------------------------
  Resources are manipulated using a fixed set of 4 operations
  1. create
  2. read
  3. update
  4. delete 
  
  These operations can be perform using below HTTP Methods respectively
  1. PUT (creates a new resource)
  2. GET (retrieves the current state of a resource in some representation)
  3. POST (transfers a new state onto a resource OR Update the existing resource)
  4. DELETE (Delete an existing resource)

  III. Self-descriptive messages:-
  ----------------------------------
  Resources are decoupled from their representation so that their content 
  can be accessed in a variety of formats, such as HTML, XML, plain text, 
  PDF, JPEG, JSON, and other formats.

> Hence RESTful web services are loosely coupled, lightweight web services 
  they are well suited for creating APIs for clients spread across the internet 


JAX-RS API
============
> JAX-RS stands for JAVA API for RESTful Web 
  Services

> JAX-RS makes it easy for developers to build 
  RESTful web services using the Java programming language as compared to SOAP/XML Web Services
  
> "javax.ws.rs.*" is the package representation 
  of JAX-RS API

> The JAX-RS API uses "annotations" to simplify 
  the development of RESTful web services. 
  So Developers 
  - can decorate Java Beans with JAX-RS  
    annotations to define resources and 
  - the actions that can be performed on those 
    resources 

  
  
  
  
Most Commonly Used HTTP Status Codes 
in RESTful Web Services
==================================================
Codes in the 100 range
are considered informational. Codes in the 200 range are considered successful. Codes
in the 300 range are success codes, but fall under the redirection category. Error codes
are in the 400 to 500 ranges. The 400s are client errors and 500s are server errors.

ADD 406
304 & 204 will not have a Body

<Successful Responses
Successful HTTP response code numbers range from 200 to 399.

If the return
value is null, a successful response code of 204, “No Content,” is returned. The 204
response is not an error condition. It just tells the client that everything went OK, but
that there is no message body to look for in the response.

If the JAX-RS resource method’s
return type is void, a response code of 204, “No Content,” is returned. This is the case
with our update() and delete() methods.

The HTTP specification is pretty consistent for the PUT, POST, GET, and DELETE
methods. If a successful HTTP response contains a message body, 200, “OK,” is the
response code. If the response doesn’t contain a message body, 204, “No Content,” must
be returned.

For our getCustomer() and create() methods, if the client requests a text/html response,
the JAX-RS implementation will automatically return a 406, “Not Acceptable,”
response code with no response body. This means that JAX-RS has a relative URI path
that matches the request, but doesn’t have a JAX-RS resource method that can produce
the client’s desired response media type. 

If the client invokes an HTTP method on a valid URI to which no JAX-RS resource
method is bound, the JAX-RS runtime will send an error code of 405, “Method Not
Allowed.” So, in our example, if our client does a PUT, GET, or DELETE on the /custom
ers URI, it will get a 405 response because POST is the only supported method for that
URI.

The JAX-RS implementation will also return an Allow response header back to
the client that contains a list of HTTP methods the URI supports. So, if our client did a
GET /customers in our example, the server would send this response back:
HTTP/1.1 405, Method Not Allowed
Allow: POST

The exception to this rule is the HTTP HEAD and OPTIONS methods. If a JAX-RS
resource method isn’t available that can service HEAD requests for that particular URI,
but there does exist a method that can handle GET, JAX-RS will invoke the JAX-RS
resource method that handles GET and return the response from that minus the request
body.

If there is no existing method that can handle OPTIONS, the JAX-RS implementation
is required to send back some meaningful, automatically generated response
along with the Allow header set.

>

> W.K.T Http Staus code is part of the Http 
  Response & its a Mandatory Information
  
> HTTP Status Codes are grouped into 5 Groups. 
  They are,
  1. 1xx Informational
  2. 2xx Success
  3. 3xx Redirection
  4. 4xx Client Error
  5. 5xx Server Error
  
> The Most Commonly used HTTP Status Codes in 
  RESTful Web Services are
  
  1. 200 OK 	
  -----------
  - Request has been successfully handled
  
  2. 201 Created
  ---------------
  - The request has been fulfilled and resulted in a new resource being created. 
  - In this case response may or may not have a body 
 
  3. 204 No Content
  ------------------
  - The request has been fulfilled however it does not need to return an response body
  - The 204 response MUST NOT contain a message-body

  4. 304 Not Modified
  --------------------
  - The request has been fulfilled however the 
    resource is not modified  
  - The 304 response MUST NOT contain a message-body
  
  5. 400 Bad Request
  ---------------------
  - The request could not be understood by the 
    server due to malformed syntax. 
  - The client SHOULD NOT repeat the request 
    without modifications.
  
  6. 401 Unauthorized
  ---------------------
  - The request requires user authentication. 
  - The response MUST include a header field 
    containing a challenge applicable to the requested resource. 
  
  7. 403 Forbidden
  -----------------------
  - The server understood the request, but is 
    refusing to fulfill it. 
  - Authorization will not help and the request 
    SHOULD NOT be repeated.
  
  8. 404 Not Found
  -----------------
  - The server has not found anything matching the 
    Request-URI 
	
  9. 405 Method Not Allowed
  -----------------------------
  - if method is annoted with @GET & if we make a request using any other method ex:- @POST we get this error. <Format this> 
  
  10.  415 - Unsupported Media Type
  ----------------------------------
  we get this Error when there is Media Type mismatch
  
  9. 409 Conflict
  -----------------
  - The request could not be completed due to a 
    conflict with the current state of the resource. 
  - This code is only allowed in situations where 
    it is expected that the user might be able to resolve the conflict and resubmit the request. 
  - The response body SHOULD include enough 
    information for the user to recognize the source of the conflict.
  
  10. 500 Internal Server Error
  -----------------------------
  - The server encountered an unexpected condition 
    which prevented it from fulfilling the request
  
  
  
  
Root Resource Classes
===========================
> They are Java Classes that are 
  - annotated with @Path 
  - have at least "one method" 
    annotated with @Path 
    OR 
    a "resource method designator" annotation (such as @GET, @PUT, @POST, @DELETE)
	
> They MUST BE "public" in nature & They MUST have "public default constructor" (ONLY in case of JAXRS–unaware servlet containers)

  
Resource Methods
====================
> They are methods of a "resource class" annotated with a "resource method designator"
> They SHOULD be public methods
> They May / May-Not return value
> i.e. the resource method may returns "void". 
  This means "No Representation" is returned and response 
  with a status code of 204 (No Content) will be returned to the client.  
  
  
  
  
  
  
  
  
  
JAX-RS Annotations
======================

1. @Path			
-----------
> It identifies a perticular "Resource Method" in a  
  "Root Resource Class"
> It can be specified at "Class" or "Method" level
> Java classes that you want to be recognized as JAX-RS services must have this annotation.
> Declaration at Class Level is Mandatory. However
  declaration at Method Level is Optional
> If its not present at Method Level then always First
  Method gets executed
> Avoid using spaces in Path Name. 
  Instead use underscore (_) or hyphen (-) while using a long resource name. 
  For example, 
  use "/create_employee" instead of 
      "/create employee"
> Use lowercase letters in Path Name
> A @Path value may or may not begin with a '/', 
  it makes no difference
> Likewise, @Path value may or may not end in a '/', 
  it makes no difference
> Thus request URLs that end or do not end in a '/' 
  will both be matched

Few Examples:
--------------------
@Path("customers/{firstname}-{lastname}")
@Path("/")  ===> Can be used with Resource Class 






2. @<Resource_Method_Designators> 
  (@GET, @POST, @PUT, @DELETE, @HEAD and @OPTIONS )
---------------------------------------------------
> This annotations are used with Java Methods & 
  they are called as "Resource Method Designator Annotations"
> The JAX-RS spec disallows multiple method designators 
  on a single Java method
> Its Mandatory Information & every Resource Method
  should have ONLY ONE Resource Method Designator
> The Java method annotated with @GET will process 
  HTTP GET requests
> The Java method annotated with @POST will process 
  HTTP POST requests
> The Java method annotated with @PUT will process   
  HTTP PUT requests
> The Java method annotated with @DELETE will process 
  HTTP DELETE requests
> The Java method annotated with @HEAD will process 
  HTTP HEAD requests
> The Java method annotated with @OPTIONS will 
  process HTTP OPTIONS requests
> NOTE: There is NO @TRACE and @CONNECT annotation

  
NOTE:
------
For Resource Methods @Path is Optional, however,
@<Resource_Method_Designators> is Mandatory (ONLY ONE)

  
3. @<*>Param (Parameter Annotations) 
  (@PathParam, @QueryParam, @FormParam, @HeaderParam, @CookieParam and @MatrixParam)
--------------------------------------------------------------------------------------
> Parameters of a "resource method" may be annotated with 
  parameter-based annotations to extract information from a request

> Usually, these annotations are used on the input arguments of a "Resource Methods"

> A. @PathParam
-----------------
  - It represents the parameter of the URI path
    Syntax : {variable_name} 
    Ex: @Path("/users/{username}") 
  
  - This annotation allows us to extract values from extract a path parameter from the path component of the request URL 
  
  - It can be used with Regular Expressions 
    Syntax : {variable_name : regular_expression} 
    Ex: @Path("{id : \\d+}") //It supports digit only

> B. @QueryParam
----------------
  - This annotation allows us to extract values from URL Query Parameters 
  

> C. @FormParam
---------------
  - This annotation allows us to extract values from "posted" form data
  - This annotation is used to access "application/x-www-form-urlencoded" request bodies.
  - In otherwords, whenever we submit the form which has method="post" then request header will 
	have "Content-Type: application/x-www-form-urlencoded" information
  - It should not be used with @GET  
  
> D. @HeaderParam	
-----------------
  - This annotation allows us to extract values from HTTP request headers
  

> E. @CookieParam	
------------------
  - This annotation allows us to extract values from HTTP request cookies 
  

> F. @MatrixParam
-------------------
  - Matrix parameters are a set of “name=value” in URI path
    For Ex: 	/users/praveen;userid=abcd
  - URI can consist of N number of Matrix parameters but they should be separate 
    by a semi colon “;“
  - They can be present anywhere in URI  
  - This annotation allows us to extract values from URI matrix parameters 
  
> All these Parameter Annotations refer various parts of an HTTP request. These parts are represented as a string of characters within the HTTP request. 

> So we can get them as a String values or else JAX-RS can convert this string data into any Java type that we want, provided that it matches one of the following criteria:
  1. Be a primitive type (byte, short, int, long, float, double, char & boolean)
  2. Have a Class Name which has constructor that accepts a single String argument
  3. Be a 
     - List<T>, 
	 - Set<T> or 
	 - SortedSet<T> 
	 resulting collection is read-only
  
  
4. @DefaultValue
---------------------
> Assigns a default value to a parameters (Parameter Annotations)
> If the @DefaultValue is not used in conjunction with "Parameter Annotations" 
  and if any parameter is not present in the request then value will be 
  - an "empty collection" for List, Set or SortedSet
  - "null" for other object types and 
  - "default values" for primitive types

  
5. @BeanParam  
-----------------
> The @BeanParam annotation is something new added in the JAX-RS 2.0 specification.
> It allows you to inject an application-specific class whose property methods or fields are annotated with "Parameter Annotations"  
> The JAX-RS runtime will introspect the @BeanParam parameter’s type for injection annotations and then set them as appropriate.
  
 
6. @HttpMethod
-------------------
> can create new annotations that bind to HTTP methods other than GET, POST, PUT, DELETE, HEAD and PUT.
> While HTTP is a ubiquitous, stable protocol, it is still constantly evolving. For example, consider the WebDAV protocol.

> WebDAV protocol
-----------------------
  - The WebDAV protocol makes the Web an interactive readable and writable medium. 
  - It allows users to create, change, and move documents on web servers. 
  - It does this by adding a bunch of new methods to HTTP like MOVE, COPY, MKCOL, LOCK, and UNLOCK.> 

> Although JAX-RS does not define any WebDAV-specific annotations, we could create them ourselves using the @HttpMethod annotation:

	package org.rest.webdav;

	import ...;

	@Target({ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@HttpMethod("LOCK")
	public @interface LOCK {
	  ...
	}

> Here, we have defined a new @org.rest.LOCK annotation using @HttpMethod to specify the HTTP operation it binds to. We can then use it on JAX-RS resource methods:

	@Path("/employee")
	public class EmployeeResource {

	   @Path("{id}")
	   @LOCK
	   public void lockEmployeeID(@PathParam("id") String id) {
		  ...
	   }
	}

	
> Now WebDAV clients can invoke LOCK operations on our web server and they will be dispatched to the lockEmployeeID() method.	
	
7. @Encoded
--------------
> "Parameter Annotations" must all be encoded by the HTTP specification. 
> By default, JAX-RS decodes these values before converting them into the desired Java types. 
> Sometimes, we may want to work with the raw encoded values. 
> In this case, using the @javax.ws.rs.Encoded annotation gives you the desired effect:	
> Ex:
-----
  @GET
  @Produces("application/xml")
  public String getData(@Encoded @QueryParam("regno") String regNum) {...}

















  
8. @Produces
---------------
> This annotation is used to specify the MIME media 
  types of representations a resource can produce and send back to the client
  
> For example, 
  - "text/plain", 
  - "application/json", 
  - "application/xml", etc.,
  
> @Produces can be applied at both the class as well 
  as at method levels
  
> If @Produces is applied at the class level, all the 
  methods in a resource can produce the specified   MIME types by default
  
> If it is applied at the method level, it overrides 
  any @Produces annotations applied at the class level

> For Example:
  
  @Path("/myResource")
  @Produces("text/plain")
  public class SomeResource 
  {
      @GET
      public String doGetAsPlainText() {
          ...
      }
   
      @GET
      @Produces("text/html")
      public String doGetAsHtml() {
          ...
      }
  }
 
 - The doGetAsPlainText method defaults to the MIME 
   type of the @Produces annotation at the class level
   
 - The doGetAsHtml method's @Produces annotation 
   overrides the class-level @Produces setting, and specifies that the method can produce HTML rather than plain text
  
> The value of @Produces is an array of String of 
  MIME types. For example:
  @Produces({"image/jpeg", "image/png"})

> Hence more than one media type may be declared in   
  the same @Produces declaration. 

  Ex:
  ---
  @GET
  @Produces({"application/xml", "application/json"})
  public String doGetAsXmlOrJson() {
  ...
  } 

- The doGetAsXmlOrJson method will get invoked if 
  either of the media types application/xml and application/json are acceptable 

- If both are equally acceptable (i.e. Request with 
  Accept Header value as "*/*"), then the former will be chosen because it occurs first
  
> If no methods in a resource are able to produce the 
  MIME type in a client request, the Jersey runtime sends back an HTTP “406 Not Acceptable” error 
  
10. @Consumes
---------------
> This annotation is used to specify the MIME media 
  types of representations a resource can consume from the client
  
> @Consumes can be applied at both the class and the 
  method levels 

> If it is applied at the class level, all the methods
  in a resource can consume the specified MIME types by default 

> If it is applied at the method level, it overrides 
  any @Consumes annotations applied at the class level

> The value of @Consumes is an array of String of 
  acceptable MIME types. For example:
  @Consumes({"text/plain", "text/html"})

> If a resource is unable to consume the MIME type of 
  a client request, the Jersey runtime sends back an HTTP “415 Unsupported Media Type” error

javax.ws.rs.core.MediaType
===============================
> It's a Concreate Class part of JAX-RS API which has 
  lot of Constants with most popular MIME Types

> Rather than typing MIME media types, It is possible 
  to refer to constant values, which may reduce typographical errors

EX:-
------
Rather than typing 
@Produces("application/xml")

We can use
@Produces(MediaType.APPLICATION_XML)

JAXB and JSON JAX-RS Handlers
=================================
> Once we apply JAXB annotations to Java classes, 
  with JAX-RS API it is very easy to exchange XML/JSON data between client and web services

> The built-in JAXB and JSON (Jettison, Jackson, etc.,)
  handlers will automatically takescare of Marshalling 
  & Unmarshalling of these Java Classes to XML/JSON

> Also, by default, JAX-RS API will take care of the 
  creation and initialization of JAXBContext instances
  
> Because the creation of JAXBContext instances can 
  be expensive, JAX-RS implementations usually cache them after they are first initialized.














	









javax.ws.rs.core.Response
============================
> Many times we may need to send "additional information OR Metadata information" along with the response like Cookies, Last Modified Date, Language, Cacheing Information, Location URI of the Newly created Resource, etc.,

> In such cases, resource methods can return instances of javax.ws.rs.core.Response

> "javax.ws.rs.core.Response" is an Abstrat Class and 
  "javax.ws.rs.core.Response.ResponseBuilder" is an inner abstract class of Response. 
  Both are part of JAX-RS API and both classes have couple of abstract methods. 

> The Classes which extends above abstract classes are in Jersey Framework
1. org.glassfish.jersey.message.internal.OutboundJaxrsResponse extends Response
2. org.glassfish.jersey.message.internal.OutboundJaxrsResponse$Builder extends ResponseBuilder

> Hence implementation of abstract methods present in Response & ResponseBuilder classes are provided in Jersey Framework. 

> Response object cannot be created directly; instead, 
  1. First we need to get the javax.ws.rs.core.Response.ResponseBuilder Object by invoking one of the static helper methods (depending on our need) of javax.ws.rs.core.Response
  
  2. ResponseBuilder object has many non-static methods which would help us to set the Metadata information to Response. Hence we need to invoke one/more non-static methods (depending on our need) on ResponseBuilder
  
  3. Finally invoke build() method to get the Response objects
  
  Psuedo-Code 
  ------------
  ResponseBuilder builder = Response.one-of-the-Static_Methods();
  builder.one-or-more-Non_Static_Methods();
  Response resp = builder.build();

> The ResponseBuilder class is a factory that helps to create one individual Response object

> For example, below is the code which returns 201 (Created) status code and a Location header whose value is the URI to the newly created resource

  @POST
  @Consumes("application/xml")
  public Response createResource(String content) 
  {
    //Code to Create the Resource using content
    URI createdUri = ...
    return Response.created(createdUri).build();
  }






The Status Enum (javax.ws.rs.core.Response.Status)
=======================================================
> It's always better to have a numeric constant to set a Response status code rather than hardcoding to aviod typographical errors

> The JAX-RS specification provides a "Java Enum" called javax.ws.rs.core.Response.Status for this purpose

> Status is an Enum declared inside "javax.ws.rs.core.Response" class

> It consist of Constants for commonly used status codes defined by HTTP
  Ex:- Response.Status.NOT_FOUND




















Handling Cookies in RESTFul Web Services
==============================================
> W.K.T Cookies are little piece of information in the form of "name=value String pair" exchanged between Client & Server
> Servers can store state information in cookies on the client, and can retrieve that information
when the client makes its next request
> Many web applications use cookies to set up a session between the client and the server. 
> They also use cookies to remember identity and user preferences between requests. These cookie values are transmitted back and forth between the client and server


1. Sending Cookie as part of the Response:-
-------------------------------------------
> javax.ws.rs.core.NewCookie is a Concreate Class part of JAX-RS API which extends javax.ws.rs.core.Cookie  
> It's used to create a new HTTP cookie and transferred as part of a response.
> To set cookies as part of response, create instances of NewCookie and pass them to the method ResponseBuilder.cookie(). 

> example:
-----------
@Path("/myservice")
public class MyService 
{
	@GET
	public Response get() 
	{
		NewCookie cookie = new NewCookie("key", "value");
		ResponseBuilder builder = Response.ok("hello", "text/plain");
		return builder.cookie(cookie).build();
	}
}



2. Getting Cookie from the Request:-
-------------------------------------------
> javax.ws.rs.core.Cookie Represents the value of a HTTP cookie, transferred in a request

> The @javax.ws.rs.CookieParam annotation allows us to inject cookies sent by a client
request into your JAX-RS resource methods. 

> For example, let’s say if web service sends a customerId cookie to clients so that we can track users as they invoke and interact with our web services, code to pull in this information might look like this:

@Path("/myservice")
public class MyService 
{
	@GET
	@Produces("text/html")
	public String get(@CookieParam("customerId") int custId) 
	{
		...
	}
}

> @CookieParam makes JAX-RS to search all cookies with the name "customerId". It then converts the correspondig value into an int and injects it into the custId parameter.

> If we need more information about the cookie other than its value, we can instead inject a javax.ws.rs.core.Cookie object

@Path("/myservice")
public class MyService 
{
	@GET
	@Produces("text/html")
	public String get(@CookieParam("customerId") Cookie custCookie) 
	{
		...
	}
}

> The Cookie class has additional contextual information about the cookie beyond its name and value:

package javax.ws.rs.core;

public class Cookie
{
	public String getName() {...}
	public String getValue() {...}
	public int getVersion() {...}
	public String getDomain() {...}
	public String getPath() {...}
	...
}

NOTE:-
=======
- Use javax.ws.rs.core.NewCookie to send the Cookies as part of the Response
- Use javax.ws.rs.core.Cookie to get the Cookie information from Request


HTTP "Content-Disposition" Header
===================================
> It's optional in HTTP can be present either in HTTP Request or Response

> Content-Disposition in HTTP Response indicates 
  - if the content is to be displayed in the browser or 
  - as an attachment (i.e. downloaded and saved locally)

> Content-Disposition will be present ONLY in "multipart/form-data" HTTP Request Body. It's subpart of a multipart body to give information about the field it applies to. The subpart is delimited by the boundary defined in the Content-Type header. 
  
> Syntax for HTTP Request Header
  Content-Disposition: form-data
  Content-Disposition: form-data; name="fieldName"
  Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
  
> Syntax for HTTP Response Header
  Content-Disposition: inline
  Content-Disposition: attachment
  Content-Disposition: attachment; filename="filename.jpg"

> The first parameter of "Content-Disposition" in "HTTP Response Header" is either  
  - "inline" (default value, indicating it can be display inside the Web page, or as the Web page) or 
  - "attachment" (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the filename parameters if present

> The first parameter of "Content-Disposition" in "HTTP Request Header" is always "form-data".   
  Additional parameters are case-insensitive and have arguments, that use quoted-string syntax after the '=' sign. Multiple parameters are separated by a semi-colon (';').

javax.ws.rs.core.HttpHeaders
=============================
> It's an interface part of JAX-RS API which has various varibales which indicates/represents various headers of HTTP

> to aviod typographical errors it's always better to use these constants whenever we need to deal with HTTP headers


Dealing with Large Binary Objects (i.e. Uploading File) using Jersey 
=======================================================================
> While developing web services we may need to create web services which needs to deal with large binary Objects such as images, documents and various types of media files

> When "Web Service Consumer" wants to upload any files then
  - Request SHOULD have method="post" and 
  - Request should have encoded POST body

> For this Consumer have to use, enctype="multipart/form-data" encoding to deal with a large binary object uploaded via <input type="file">

> Unfortunately, JAX-RS API doesnot have standardized Annotation to deal with large files

> to overcome this probelm Jersey provides "@FormDataParam" Annotation

@FormDataParam Annotation
===========================
> This annotation binds the named body part(s) of a "multipart/form-data" request entity body to a   
  - resource method parameter or 
  - a class memeber variable (@BeanParam) as appropriate

> This annotation  should be used in conjunction with the media type "multipart/form-data" should be used for submitting and consuming forms that contain files, non-ASCII data, and binary data.

> Jersey allows to inject @FormDataParam onto following parameter types
  - Any type of parameter for which a message body reader is avilable
  - "org.glassfish.jersey.media.multipart.FormDataContentDisposition" 
    this represents the form data content disposition header 
  
> "FormDataContentDisposition" is a concreate class of Jersey which consist 
  of Metadata information of the "multipart/form-data" request 
  like file name, size, creation date, etc.,


More About Root Resource Class
==================================
> So far, we’ve applied JAX-RS annotations directly on the Java class that has RESTful web services

> In JAX-RS, we are also allowed to define a Java interface that contains all our JAX-RS annotation metadata instead of applying all our annotations to our implementation class

Ex:-
====
import ....

public interface FileDownloadService 
{
	@GET
	@Path("/image")
	@Produces("image/png")
	public Response getImageFile();
}


> With an interface, we can defines web service methods that gives high level picture on how our RESTful services looks like without exposing implementation  details

> Interfaces are a great way to isolate all this metadata into one logical and readable construct

> Hence they helps us to achieve readbility because business logic isn’t “polluted” with so many annotations

> The implementation class looks like

@Path("/file/download")
public class FileDownloadServiceImpl implements FileDownloadService {

	public Response getImageFile() {
		.....
		.....
		.....
	}
}

NOTE: 
-------
- @Path SHOULD be present at class level not at Interface level
- Hence, Interfaces helps us to design our services based on our need (with more than one implementation class with different @Path)

> As we can see, except @Path, no other JAX-RS annotations are needed within the implementing class. 
All our metadata is confined to the FileDownloadService interface.

> If we want to, we can override the metadata defined in our interfaces by reapplying
annotations within our implementation class. For example,

@Path("/file/download")
public class FileDownloadServiceImpl implements FileDownloadService {

	@GET
	@Path("/img")
	@Produces("image/png")
	public Response getImageFile() {
		.....
		.....
		.....
	}
}
 
> In the above example, we are overriding the metadata defined in an interface for one specific
method. "When overriding metadata for a method, you must specify all the annotation
metadata for that method even if you are changing only one small thing"

> However, it is not recommend to override metadata in implementation class. 

> The whole point of using an interface to apply our JAX-RS metadata is to isolate the information and define it in one place. If annotations are scattered about between implementation class & interface, then code becomes a lot harder to read and understand

> It's also possible that root resource class can have super class (Abstract & Concrete)

> If Super Class is an Abstract Class then it SHOULD NOT have @Path at class level











Deployment and Integration
====================================
> JAX-RS Web Applications can be deployed 

  1. within a standalone servlet container, like 
     - Apache Tomcat
     - Jetty
     - JBossWeb, etc., 
	 
  2. within the servlet container of Application Server, like 
     - JBoss 
     - Wildfly
     - Weblogic
     - Websphere or 
     - Glassfish, etc.,
  
> How JAX-RS Web Applications is deployed within a servlet container varies between 

  1. JAX-RS-Aware Servlet Containers 
     (like any JavaEE supported Application Servers or 
      standalone Servlet 3.x containers like Tomcat) 
  
  2. JAXRS–Unaware (Older) Servlet Containers

Deployment within JAX-RS-Aware Containers
===========================================
> Application servers that are certified under Java EE 6 are required to 
  have built-in support for JAXRS 1.1
  
> Application servers that are certified under Java EE 7 are required to 
  have built-in support for JAX-RS 2.0
  
> To deploy JAX-RS application in JAX-RS-Aware Containers, 
  we should have 
  - at least one Java Class which extends "javax.ws.rs.core.Application" and
  - annotated with "@ApplicationPath"
  then JAX-RS–aware container will automatically deploy that Application

> For Example :-
  --------------
  package com.mycomp.myapp;
  
  import javax.ws.rs.ApplicationPath;
  import javax.ws.rs.core.Application;
  
  @ApplicationPath("/services")
  public class MyRestApplication extends Application 
  {
	....
	....
  }

> The @ApplicationPath annotation will set up a base path to whatever the WAR’s context root is.
  If WAR file name is "mywebapp" then URL will looks like,
  
  http://<Domain-Name>:<Port>/mywebapp/services/<Paths-of-Root_Resource_Class_and_Method>

javax.ws.rs.core.Application
==============================
> It's a Concreate Class present in JAX-RS API 

> The Application class is the only portable way of telling container that 
  which web services (@Path annotated classes) we want to be deployed. 
  This Class list "Classes and Objects" that JAX-RS is supposed to deploy. 
  
> Application Class has below 3 methods & hence subclass of this class can 
  override any/all/none of these methods
  1. public Set<Class<?>> getClasses()
  2. public Set<Object> getSingletons()
  3. public Map<String, Object> getProperties()
  
> The getClasses() method returns a list of JAX-RS web service and provider classes. 
  These Classes will get instantiated once request comes & garbage collected once response is given (non-singleton in nature). These Classes SHOULD have public default constructor. In this case, its a Container responsibility to create an instance of resource class
  
> The getSingletons() method returns a list of preallocated JAX-RS web services and providers. 
  These Classes will get instantiated during the server start-up & garbage collected during the server shut down. Hence they are "singleton" in nature. These Classes need not to have public default constructor. In this case, we as a developer, are responsible for creating these objects.

> The getProperties() method returns a map of custom application-wide properties

> The JAX-RS runtime will iterate through the list of objects and register them internally.

> Along with creating a class which extends Application class we still need at least an 
  empty web.xml file:
  
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns="http://java.sun.com/xml/ns/javaee"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
								http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
								version="3.0">
   </web-app>

NOTE:-
======
> We can fully leverage "servlet class scanning abilities" of application server incase 
  if we don't override getClasses() and getSingletons() OR both return an empty set
  
> For Example:-
  -------------
  @ApplicationPath("/services")
  public class MyRestApplication extends Application 
  {
	//Empty Class
  }
   
> When scanning, the application server will look within WEB-INF/classes and any JAR
file within the WEB-INF/lib directory

> It will add any class annotated with @Path to the list of things that need to be deployed and registered with the JAX-RS runtime

> You can also deploy as many Application classes as you want in one WAR

> The scanner will also ignore any Application classes not annotated with @ApplicationPath

> You can also override the @ApplicationPath annotation via a simple servlet mapping
  within web.xml:

   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns="http://java.sun.com/xml/ns/javaee"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
								http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
								version="3.0">
		<servlet-mapping>
			<servlet-name>com.mycomp.myapp.MyRestApplication</servlet-name>
			<url-pattern>/*</url-pattern>
		</servlet-mapping>
   </web-app>
   
> The servlet-name is the fully qualified class name of your Application class. 
  In this case, we can also omit the @ApplicationPath annotation entirely.



Deployment within a JAX-RS-Unaware Container
================================================
> If Servlet containers are 2.x or older then we have to manually configure web.xml 
  to load your JAX-RS implementation’s proprietary servlet class

> For Example, 

  Jersey
  --------

  <servlet>
  	<servlet-name>GlashFishJersey</servlet-name>
  	<servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
  	<init-param>
  		<param-name>jersey.config.server.provider.packages</param-name>
  		<param-value>com.mycomp.myapp;</param-value>
  	</init-param>
  </servlet>
  
  <servlet-mapping>
  	<servlet-name>GlashFishJersey</servlet-name>
  	<url-pattern>/rest/*</url-pattern>
  </servlet-mapping>

  RestEasy
  --------
  
  <servlet>
	<servlet-name>JAXRS</servlet-name>
	<servlet-class>org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher</servlet-class>
	<init-param>
		<param-name>javax.ws.rs.Application</param-name>
		<param-value>com.mycomp.myapp.MyRestApplication</param-value>
	</init-param>
  </servlet>
  
  <servlet-mapping>
	<servlet-name>JAXRS</servlet-name>
	<url-pattern>/*</url-pattern>
  </servlet-mapping>

> The <servletmapping> specifies the base URI path for the JAX-RS runtime

> The <urlpattern> specifies that all incoming requests should be routed through our JAX-RS implementation. URL pattern should end with *

> "ServletContainer" in case of Jersey is a Concreate Class which extends HttpServlet. In otherwords
  its a Servlet, takes the all the incoming requests & routes to correspondig resource class





  
  
  
  
  
  
  
  
  
  
  
  
JAX-RS Client API 
====================
> The JAX-RS Client API provides a high-level API for accessing any REST resources, not just JAX-RS services. 

> The Client API is defined in the "javax.ws.rs.client.*" package

> The following steps are needed to access a REST resource using the Client API.
1. Obtain an instance of the javax.ws.rs.client.Client interface
2. Configure the Client instance with a target
3. Create a request based on the target
4. Invoke the request
5. Process the Response


1. Obtaining the Client Instance
====================================
> To utilize the client API it is first necessary to build an instance of a Client using one of the static ClientBuilder factory methods.

  //First Approch
  Client client = ClientBuilder.newClient();  
  
  OR
  
  //Second Approch
  ClientBuilder builder = ClientBuilder.newBuilder(); 
  Client client = builder.build();

> ClientBuilder is an Abstract Class part of JAX-RS API which has "N" number of Abstract Methods is the Main entry point to the client API. 

> "org.glassfish.jersey.client.JerseyClientBuilder" part of Jersey framework is a concreate class which 
  extends ClientBuilder
  
  public class JerseyClientBuilder extends ClientBuilder

> newBuilder() is a Static method of ClientBuilder Create a new instance of ClientBuilder 

> build() is a non-static method but abstract method, return type is Object of type "Client"
  public abstract Client build();

> Hence the implemetation of this method is provided by the JAX-RS implementation provider such as Jersey, CXF, etc.,


> newClient() is a Static method of ClientBuilder, it returns new Client instance 

> newClient() method  which internally invokes "newBuilder().build()"
  
    public static Client newClient() {
        return newBuilder().build();
    }

> "javax.ws.rs.client.Client" is an Interface part of JAX-RS API. Implementation class provided by the JAX-RS implementation provider such as Jersey, CXF, RestEasy, etc.,

> "org.glassfish.jersey.client.JerseyClient" part of Jersey framework is a concreate class which  
   implements "javax.ws.rs.client.Client"
   
   public class JerseyClient implements javax.ws.rs.client.Client
  
> We can go for 2nd approch, in a slightly more advanced scenarios (i.e. if you want to interact with web services using https protocol), where ClientBuilder can be used to configure additional client instance properties, such as a SSL transport settings, etc.,
  
> For http we can go for First Approch

> Use the close() method to close Client instances after it's job is done

> Client instances are heavyweight objects. For performance reasons, limit the number
of Client instances, as the initialization and destruction of these instances may be expensive 


*/
2. Setting the Client Target
===============================
> The target of a client, the REST resource at a particular URI, is represented by an instance of the 
javax.ws.rs.client.WebTarget interface.

> we can obtain a WebTarget instance by invoking target() method and passing in the URI of the target REST resource.

Client client = ClientBuilder.newClient();
WebTarget myResource 
        = client.target("http://www.example.com/webapi");

> "javax.ws.rs.client.WebTarget" is an Interface part of  
  JAX-RS API

> "org.glassfish.jersey.client.JerseyWebTarget" part of Jersey framework is a concreate class which  implements "javax.ws.rs.client.WebTarget"   

> For complex REST resources, it may be beneficial to create several instances of WebTarget. For example, 

Client client = ClientBuilder.newClient();
WebTarget base 
         = client.target("http://www.example.com/webapi");

//http://www.example.com/webapi/read
WebTarget read = base.path("read");

//http://www.example.com/webapi/write
WebTarget write = base.path("write");
  
> In the above example, a base target is used to construct
 several other targets that represent different services provided by a REST resource.

> The WebTarget.path() method creates a new WebTarget instance by appending the current target URI with the path that was passed in
  
  
  
  
  
  
  

3. Create a request based on the target
=========================================
> After setting and applying any configuration options to the target, we one of the WebTarget.request() methods to begin creating the request. 
  
> This is usually accomplished by passing to WebTarget.request() the accepted media response type for the request 
- either as a string of the MIME type or 
- using one of the constants in javax.ws.rs.core.MediaType
  
> The WebTarget.request() method returns an instance of javax.ws.rs.client.Invocation.Builder, a helper object that provides methods for preparing the client request.

> "Invocation" is an Interface and "Builder" is a 
  inner-interface of "Invocation"

> Invocation.Builder has a lot of methods that allow us to 
  - set different types of request headers
  - various acceptXXX() methods for content negotiation
  - cookie() methods allow us to set HTTP cookies you want to return to the server

> NOTE:-
---------
- WebTarget has additional request() methods whose parameters take one or more String or MediaType parameters

- These parameters are media types you want to include in an Accept header

- It makes the code more readable if you use the Invocation.Builder.accept() method instead. However it's a matter of personal preference
  
> Example:-
----------------
Client client = ClientBuilder.newClient();
WebTarget target 
    = client.target("http://www.example.com/webapi/read");

Invocation.Builder builder 
                 //= target.request("text/html"); OR
                   = target.request(MediaType.TEXT_HTML);
//OR

WebTarget target 
     = client.target("http://www.example.com/webapi/read");
target.request(MediaType.TEXT_HTML)  
Invocation.Builder builder = target.request();







4. Invoke the request
=============================
> After setting the media type, invoke the request by calling one of the methods of the Invocation.Builder instance that corresponds to the type of HTTP request the target REST resource expects. 

> These methods are:
  1. head()
  2. trace()
  3. put()
  4. post()
  5. delete()
  6. options()
  7. get()

> The return type should correspond to the entity returned by the target REST resource.

> If the target REST resource is expecting an HTTP POST request, call the Invocation.Builder.post method

StoreOrder order = new StoreOrder(...);

Client client = ClientBuilder.newClient();
WebTarget myResource 
  = client.target("http://www.example.com/webapi/write");
  
TrackingNumber trackingNumber 
	= myResource
		.request(MediaType.APPLICATION_XML)
		.post(Entity.xml(order), TrackingNumber.class);
									
> In the above example, the return type is a custom class and is retrieved by setting the type in the Invocation.Builder.post(Entity<?> entity, Class<T> responseType) method as a parameter

> If the return type is a collection, use 
javax.ws.rs.core.GenericType<T> as the response type parameter, where T is the collection type

List<StoreOrder> orders 
		= client
			.target("http://www.example.com/webapi/")
			.path("allOrders")
			.request(MediaType.APPLICATION_XML)
			.get(new GenericType<List<StoreOrder>>() {});
							
> In the above example, methods are chained together in the Client API to simplify how requests are configured and 
invoked




5. Process the Response
=========================
> Certain versions of request methods (get(), head(), 
  etc.,) returns"javax.ws.rs.core.Response" object

> This is the same Response class that is used on the server side. This gives us more fine-grained control of the HTTP response on the client side.

> For Example
----------------
import javax.ws.rs.core.Response;

Response response 
     = client
		.target("http://www.ecommerce.com/customers/123")
		.accept("application/json")
		.get();

try 
{
  if (response.getStatus() == 200) {
   Customer customer = response.readEntity(Customer.class);
  }
}finally{
  response.close();
}

> In the above example, we invoke an HTTP GET to obtain a Response object. We check that the status is OK and if so,extract a Customer object from the returned JSON document
by invoking Response.readEntity(). 

> The readEntity() method matches up the requested Java type and the response content with an appropriate MessageBodyReader

> Reponse object can be used at Producer/Server side as well as at Consumer/Client code
  - @Producer side, it's used to send the Response with additional/metadata information
  - @Consumer side, it's used to get the Response to get more information about the response

> Reponse object has lot of static methods and all of them 
returns object of "ResponseBuilder". These methods should be used for sending the Response as part of"Producer / Server" code

> Reponse object also has lot of Getter methods 
(ex:- getCookies(), getHeaders(), getLastModified(), 
 etc.,) which helps us to get additional/metadata information from Request

> NOTE:- readEntity() fectches the "actual response" and other Getter methods provides "additional information" about the response
 
> readEntity() method should be invoked only once unless we buffer the response with the bufferEntity() method. 

> For example:
-------------------
Response response 
   = client
	  .target("http://www.ecommerce.com/customers/123")
	  .accept("application/json")
	  .get();
					
try 
{
  if (response.getStatus() == 200) {
   response.bufferEntity();
   Customer customer = response.readEntity(Customer.class);
   Map rawJson = response.readEntity(Map.class);
 }
} finally {
	response.close();
}

> In the above xample, the call to bufferEntity() allows us to extract the HTTP response content into different Java types, the first type being a Customer and the second 
a java.util.Map that represents raw JSON data

> If we didn’t buffer the entity, the second readEntity() call would result in an IllegalStateException
  
> Closing Response Object:-
-------------------------------
- Once we're done with Response object we MUST close() it

- Response objects reference open socket streams. 
  If we do not close them, we're leaking system resources
  
- While most JAX-RS implementations implement a finalize() method for Response, it is not a good idea to rely on the garbage collector to clean up 

- The default behavior of the RESTEasy JAX-RS implementation actually only lets us to have one open Response per Client instance. This forces you to write responsible client code.
  


  

  


	

  
  


   
   
   
   Once you have a Client instance you can create a WebTarget from it.
   WebTarget webTarget = client.target("http://example.com/rest");

   


> "javax.ws.rs.core.Response" is an Abstract Class which has "N" number of Abstract Methods
> "org.glassfish.jersey.client.InboundJaxrsResponse" part of Jersey framework is a concreate class which 
   extends Response
   
   class InboundJaxrsResponse extends Response
   

   
  
  
  
  
  
  
  
  
  
  